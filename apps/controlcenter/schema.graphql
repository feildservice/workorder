schema {
  query: Query
  mutation: Mutation
}

type Address {
  city: String!
  country: String!
  createdAt: DateTime!
  customer: Customer!
  customerId: Int!
  id: ID!
  isPrimary: Boolean!
  latitude: Float
  longitude: Float
  state: String!
  street: String!
  updatedAt: DateTime!
  zipcode: String!
}

input AddressCreateManyCustomerInput {
  city: String!
  country: String!
  createdAt: DateTime
  id: Int
  isPrimary: Boolean!
  latitude: Float
  longitude: Float
  state: String!
  street: String!
  updatedAt: DateTime
  zipcode: String!
}

input AddressCreateManyCustomerInputEnvelope {
  data: [AddressCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input AddressCreateNestedManyWithoutCustomerInput {
  connect: [AddressWhereUniqueInput!]
  connectOrCreate: [AddressCreateOrConnectWithoutCustomerInput!]
  create: [AddressCreateWithoutCustomerInput!]
  createMany: AddressCreateManyCustomerInputEnvelope
}

input AddressCreateOrConnectWithoutCustomerInput {
  create: AddressCreateWithoutCustomerInput!
  where: AddressWhereUniqueInput!
}

input AddressCreateWithoutCustomerInput {
  city: String!
  country: String!
  createdAt: DateTime
  isPrimary: Boolean!
  latitude: Float
  longitude: Float
  state: String!
  street: String!
  updatedAt: DateTime
  zipcode: String!
}

input AddressListRelationFilter {
  every: AddressWhereInput
  none: AddressWhereInput
  some: AddressWhereInput
}

input AddressOrderByRelationAggregateInput {
  _count: SortOrder
}

input AddressScalarWhereInput {
  AND: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  city: StringFilter
  country: StringFilter
  createdAt: DateTimeFilter
  customerId: IntFilter
  id: IntFilter
  isPrimary: BoolFilter
  latitude: FloatNullableFilter
  longitude: FloatNullableFilter
  state: StringFilter
  street: StringFilter
  updatedAt: DateTimeFilter
  zipcode: StringFilter
}

input AddressUpdateManyMutationInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isPrimary: BoolFieldUpdateOperationsInput
  latitude: NullableFloatFieldUpdateOperationsInput
  longitude: NullableFloatFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  street: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zipcode: StringFieldUpdateOperationsInput
}

input AddressUpdateManyWithWhereWithoutCustomerInput {
  data: AddressUpdateManyMutationInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateManyWithoutCustomerNestedInput {
  connect: [AddressWhereUniqueInput!]
  connectOrCreate: [AddressCreateOrConnectWithoutCustomerInput!]
  create: [AddressCreateWithoutCustomerInput!]
  createMany: AddressCreateManyCustomerInputEnvelope
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [AddressUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutCustomerInput!]
}

input AddressUpdateWithWhereUniqueWithoutCustomerInput {
  data: AddressUpdateWithoutCustomerInput!
  where: AddressWhereUniqueInput!
}

input AddressUpdateWithoutCustomerInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isPrimary: BoolFieldUpdateOperationsInput
  latitude: NullableFloatFieldUpdateOperationsInput
  longitude: NullableFloatFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  street: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zipcode: StringFieldUpdateOperationsInput
}

input AddressUpsertWithWhereUniqueWithoutCustomerInput {
  create: AddressCreateWithoutCustomerInput!
  update: AddressUpdateWithoutCustomerInput!
  where: AddressWhereUniqueInput!
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  city: StringFilter
  country: StringFilter
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  id: IntFilter
  isPrimary: BoolFilter
  latitude: FloatNullableFilter
  longitude: FloatNullableFilter
  state: StringFilter
  street: StringFilter
  updatedAt: DateTimeFilter
  zipcode: StringFilter
}

input AddressWhereUniqueInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  city: StringFilter
  country: StringFilter
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  id: Int
  isPrimary: BoolFilter
  latitude: FloatNullableFilter
  longitude: FloatNullableFilter
  state: StringFilter
  street: StringFilter
  updatedAt: DateTimeFilter
  zipcode: StringFilter
}

type AffectedRows {
  count: Int!
}

type Agent {
  _count: AgentCount!
  agentType: AgentType!
  calendars: [WorkCalendar!]
  createdAt: DateTime!
  designation: String
  email: String!
  firstName: String!
  gender: Gender!
  id: ID!
  lastName: String!
  middleName: String
  phone: String
  serviceTerritories: [AgentTerritory!]
  title: String!
  updatedAt: DateTime!
}

type AgentCount {
  calendars: Int!
  serviceTerritories: Int!
}

input AgentCreateNestedOneWithoutServiceTerritoriesInput {
  connect: AgentWhereUniqueInput
  connectOrCreate: AgentCreateOrConnectWithoutServiceTerritoriesInput
  create: AgentCreateWithoutServiceTerritoriesInput
}

input AgentCreateOrConnectWithoutServiceTerritoriesInput {
  create: AgentCreateWithoutServiceTerritoriesInput!
  where: AgentWhereUniqueInput!
}

input AgentCreateWithoutServiceTerritoriesInput {
  agentType: AgentType!
  calendars: WorkCalendarCreateNestedManyWithoutAgentInput
  createdAt: DateTime
  designation: String
  email: String!
  firstName: String!
  gender: Gender
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime
}

input AgentOrderByWithRelationInput {
  agentType: SortOrder
  calendars: WorkCalendarOrderByRelationAggregateInput
  createdAt: SortOrder
  designation: SortOrderInput
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  middleName: SortOrderInput
  phone: SortOrderInput
  serviceTerritories: AgentTerritoryOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
}

input AgentRelationFilter {
  is: AgentWhereInput
  isNot: AgentWhereInput
}

type AgentTerritory {
  agent: Agent!
  agentId: Int!
  id: ID!
  subTerritory: SubTerritory!
  subTerritoryId: Int!
}

type AgentTerritoryAvgAggregate {
  agentId: Float
  id: Float
  subTerritoryId: Float
}

input AgentTerritoryAvgAggregateInput {
  agentId: Boolean
  id: Boolean
  subTerritoryId: Boolean
}

input AgentTerritoryAvgOrderByAggregateInput {
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

type AgentTerritoryCountAggregate {
  _all: Int!
  agentId: Int!
  id: Int!
  subTerritoryId: Int!
}

input AgentTerritoryCountAggregateInput {
  _all: Boolean
  agentId: Boolean
  id: Boolean
  subTerritoryId: Boolean
}

input AgentTerritoryCountOrderByAggregateInput {
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

input AgentTerritoryCreateInput {
  agent: AgentCreateNestedOneWithoutServiceTerritoriesInput!
  subTerritory: SubTerritoryCreateNestedOneWithoutAgentsInput!
}

input AgentTerritoryCreateManyInput {
  agentId: Int!
  id: Int
  subTerritoryId: Int!
}

input AgentTerritoryCreateManySubTerritoryInput {
  agentId: Int!
  id: Int
}

input AgentTerritoryCreateManySubTerritoryInputEnvelope {
  data: [AgentTerritoryCreateManySubTerritoryInput!]!
  skipDuplicates: Boolean
}

input AgentTerritoryCreateNestedManyWithoutSubTerritoryInput {
  connect: [AgentTerritoryWhereUniqueInput!]
  connectOrCreate: [AgentTerritoryCreateOrConnectWithoutSubTerritoryInput!]
  create: [AgentTerritoryCreateWithoutSubTerritoryInput!]
  createMany: AgentTerritoryCreateManySubTerritoryInputEnvelope
}

input AgentTerritoryCreateOrConnectWithoutSubTerritoryInput {
  create: AgentTerritoryCreateWithoutSubTerritoryInput!
  where: AgentTerritoryWhereUniqueInput!
}

input AgentTerritoryCreateWithoutSubTerritoryInput {
  agent: AgentCreateNestedOneWithoutServiceTerritoriesInput!
}

type AgentTerritoryGroupBy {
  _avg: AgentTerritoryAvgAggregate
  _count: AgentTerritoryCountAggregate
  _max: AgentTerritoryMaxAggregate
  _min: AgentTerritoryMinAggregate
  _sum: AgentTerritorySumAggregate
  agentId: Int!
  id: Int!
  subTerritoryId: Int!
}

input AgentTerritoryListRelationFilter {
  every: AgentTerritoryWhereInput
  none: AgentTerritoryWhereInput
  some: AgentTerritoryWhereInput
}

type AgentTerritoryMaxAggregate {
  agentId: Int
  id: Int
  subTerritoryId: Int
}

input AgentTerritoryMaxAggregateInput {
  agentId: Boolean
  id: Boolean
  subTerritoryId: Boolean
}

input AgentTerritoryMaxOrderByAggregateInput {
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

type AgentTerritoryMinAggregate {
  agentId: Int
  id: Int
  subTerritoryId: Int
}

input AgentTerritoryMinAggregateInput {
  agentId: Boolean
  id: Boolean
  subTerritoryId: Boolean
}

input AgentTerritoryMinOrderByAggregateInput {
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

input AgentTerritoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input AgentTerritoryOrderByWithAggregationInput {
  _avg: AgentTerritoryAvgOrderByAggregateInput
  _count: AgentTerritoryCountOrderByAggregateInput
  _max: AgentTerritoryMaxOrderByAggregateInput
  _min: AgentTerritoryMinOrderByAggregateInput
  _sum: AgentTerritorySumOrderByAggregateInput
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

input AgentTerritoryOrderByWithRelationInput {
  agent: AgentOrderByWithRelationInput
  agentId: SortOrder
  id: SortOrder
  subTerritory: SubTerritoryOrderByWithRelationInput
  subTerritoryId: SortOrder
}

enum AgentTerritoryScalarFieldEnum {
  agentId
  id
  subTerritoryId
}

input AgentTerritoryScalarWhereInput {
  AND: [AgentTerritoryScalarWhereInput!]
  NOT: [AgentTerritoryScalarWhereInput!]
  OR: [AgentTerritoryScalarWhereInput!]
  agentId: IntFilter
  id: IntFilter
  subTerritoryId: IntFilter
}

input AgentTerritoryScalarWhereWithAggregatesInput {
  AND: [AgentTerritoryScalarWhereWithAggregatesInput!]
  NOT: [AgentTerritoryScalarWhereWithAggregatesInput!]
  OR: [AgentTerritoryScalarWhereWithAggregatesInput!]
  agentId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  subTerritoryId: IntWithAggregatesFilter
}

type AgentTerritorySumAggregate {
  agentId: Int
  id: Int
  subTerritoryId: Int
}

input AgentTerritorySumAggregateInput {
  agentId: Boolean
  id: Boolean
  subTerritoryId: Boolean
}

input AgentTerritorySumOrderByAggregateInput {
  agentId: SortOrder
  id: SortOrder
  subTerritoryId: SortOrder
}

input AgentTerritoryUncheckedUpdateManyInput {
  agentId: IntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
  subTerritoryId: IntFieldUpdateOperationsInput
}

input AgentTerritoryUncheckedUpdateManyWithoutSubTerritoryInput {
  agentId: IntFieldUpdateOperationsInput
  id: IntFieldUpdateOperationsInput
}

input AgentTerritoryUpdateInput {
  agent: AgentUpdateOneRequiredWithoutServiceTerritoriesNestedInput
  subTerritory: SubTerritoryUpdateOneRequiredWithoutAgentsNestedInput
}

input AgentTerritoryUpdateManyWithWhereWithoutSubTerritoryInput {
  data: AgentTerritoryUncheckedUpdateManyWithoutSubTerritoryInput!
  where: AgentTerritoryScalarWhereInput!
}

input AgentTerritoryUpdateManyWithoutSubTerritoryNestedInput {
  connect: [AgentTerritoryWhereUniqueInput!]
  connectOrCreate: [AgentTerritoryCreateOrConnectWithoutSubTerritoryInput!]
  create: [AgentTerritoryCreateWithoutSubTerritoryInput!]
  createMany: AgentTerritoryCreateManySubTerritoryInputEnvelope
  delete: [AgentTerritoryWhereUniqueInput!]
  deleteMany: [AgentTerritoryScalarWhereInput!]
  disconnect: [AgentTerritoryWhereUniqueInput!]
  set: [AgentTerritoryWhereUniqueInput!]
  update: [AgentTerritoryUpdateWithWhereUniqueWithoutSubTerritoryInput!]
  updateMany: [AgentTerritoryUpdateManyWithWhereWithoutSubTerritoryInput!]
  upsert: [AgentTerritoryUpsertWithWhereUniqueWithoutSubTerritoryInput!]
}

input AgentTerritoryUpdateWithWhereUniqueWithoutSubTerritoryInput {
  data: AgentTerritoryUpdateWithoutSubTerritoryInput!
  where: AgentTerritoryWhereUniqueInput!
}

input AgentTerritoryUpdateWithoutSubTerritoryInput {
  agent: AgentUpdateOneRequiredWithoutServiceTerritoriesNestedInput
}

input AgentTerritoryUpsertWithWhereUniqueWithoutSubTerritoryInput {
  create: AgentTerritoryCreateWithoutSubTerritoryInput!
  update: AgentTerritoryUpdateWithoutSubTerritoryInput!
  where: AgentTerritoryWhereUniqueInput!
}

input AgentTerritoryWhereInput {
  AND: [AgentTerritoryWhereInput!]
  NOT: [AgentTerritoryWhereInput!]
  OR: [AgentTerritoryWhereInput!]
  agent: AgentRelationFilter
  agentId: IntFilter
  id: IntFilter
  subTerritory: SubTerritoryRelationFilter
  subTerritoryId: IntFilter
}

input AgentTerritoryWhereUniqueInput {
  AND: [AgentTerritoryWhereInput!]
  NOT: [AgentTerritoryWhereInput!]
  OR: [AgentTerritoryWhereInput!]
  agent: AgentRelationFilter
  agentId: IntFilter
  id: Int
  subTerritory: SubTerritoryRelationFilter
  subTerritoryId: IntFilter
}

enum AgentType {
  CUSTOMER_AGENT
  FIELD_TECHNICIAN
}

input AgentUpdateOneRequiredWithoutServiceTerritoriesNestedInput {
  connect: AgentWhereUniqueInput
  connectOrCreate: AgentCreateOrConnectWithoutServiceTerritoriesInput
  create: AgentCreateWithoutServiceTerritoriesInput
  update: AgentUpdateToOneWithWhereWithoutServiceTerritoriesInput
  upsert: AgentUpsertWithoutServiceTerritoriesInput
}

input AgentUpdateToOneWithWhereWithoutServiceTerritoriesInput {
  data: AgentUpdateWithoutServiceTerritoriesInput!
  where: AgentWhereInput
}

input AgentUpdateWithoutServiceTerritoriesInput {
  agentType: EnumAgentTypeFieldUpdateOperationsInput
  calendars: WorkCalendarUpdateManyWithoutAgentNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  designation: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AgentUpsertWithoutServiceTerritoriesInput {
  create: AgentCreateWithoutServiceTerritoriesInput!
  update: AgentUpdateWithoutServiceTerritoriesInput!
  where: AgentWhereInput
}

input AgentWhereInput {
  AND: [AgentWhereInput!]
  NOT: [AgentWhereInput!]
  OR: [AgentWhereInput!]
  agentType: EnumAgentTypeFilter
  calendars: WorkCalendarListRelationFilter
  createdAt: DateTimeFilter
  designation: StringNullableFilter
  email: StringFilter
  firstName: StringFilter
  gender: EnumGenderFilter
  id: IntFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  phone: StringNullableFilter
  serviceTerritories: AgentTerritoryListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AgentWhereUniqueInput {
  AND: [AgentWhereInput!]
  NOT: [AgentWhereInput!]
  OR: [AgentWhereInput!]
  agentType: EnumAgentTypeFilter
  calendars: WorkCalendarListRelationFilter
  createdAt: DateTimeFilter
  designation: StringNullableFilter
  email: String
  firstName: StringFilter
  gender: EnumGenderFilter
  id: Int
  lastName: StringFilter
  middleName: StringNullableFilter
  phone: StringNullableFilter
  serviceTerritories: AgentTerritoryListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type AggregateAgentTerritory {
  _avg: AgentTerritoryAvgAggregate
  _count: AgentTerritoryCountAggregate
  _max: AgentTerritoryMaxAggregate
  _min: AgentTerritoryMinAggregate
  _sum: AgentTerritorySumAggregate
}

type AggregateContact {
  _avg: ContactAvgAggregate
  _count: ContactCountAggregate
  _max: ContactMaxAggregate
  _min: ContactMinAggregate
  _sum: ContactSumAggregate
}

type AggregateCustomer {
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
}

type AggregateOrganization {
  _avg: OrganizationAvgAggregate
  _count: OrganizationCountAggregate
  _max: OrganizationMaxAggregate
  _min: OrganizationMinAggregate
  _sum: OrganizationSumAggregate
}

type AggregateServiceTerritory {
  _avg: ServiceTerritoryAvgAggregate
  _count: ServiceTerritoryCountAggregate
  _max: ServiceTerritoryMaxAggregate
  _min: ServiceTerritoryMinAggregate
  _sum: ServiceTerritorySumAggregate
}

type Agreement {
  createdAt: DateTime!
  customer: Customer!
  customerId: Int!
  description: String!
  id: ID!
  title: String!
  updatedAt: DateTime!
}

input AgreementCreateManyCustomerInput {
  createdAt: DateTime
  description: String!
  id: Int
  title: String!
  updatedAt: DateTime
}

input AgreementCreateManyCustomerInputEnvelope {
  data: [AgreementCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input AgreementCreateNestedManyWithoutCustomerInput {
  connect: [AgreementWhereUniqueInput!]
  connectOrCreate: [AgreementCreateOrConnectWithoutCustomerInput!]
  create: [AgreementCreateWithoutCustomerInput!]
  createMany: AgreementCreateManyCustomerInputEnvelope
}

input AgreementCreateOrConnectWithoutCustomerInput {
  create: AgreementCreateWithoutCustomerInput!
  where: AgreementWhereUniqueInput!
}

input AgreementCreateWithoutCustomerInput {
  createdAt: DateTime
  description: String!
  title: String!
  updatedAt: DateTime
}

input AgreementListRelationFilter {
  every: AgreementWhereInput
  none: AgreementWhereInput
  some: AgreementWhereInput
}

input AgreementOrderByRelationAggregateInput {
  _count: SortOrder
}

input AgreementScalarWhereInput {
  AND: [AgreementScalarWhereInput!]
  NOT: [AgreementScalarWhereInput!]
  OR: [AgreementScalarWhereInput!]
  createdAt: DateTimeFilter
  customerId: IntFilter
  description: StringFilter
  id: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AgreementUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AgreementUpdateManyWithWhereWithoutCustomerInput {
  data: AgreementUpdateManyMutationInput!
  where: AgreementScalarWhereInput!
}

input AgreementUpdateManyWithoutCustomerNestedInput {
  connect: [AgreementWhereUniqueInput!]
  connectOrCreate: [AgreementCreateOrConnectWithoutCustomerInput!]
  create: [AgreementCreateWithoutCustomerInput!]
  createMany: AgreementCreateManyCustomerInputEnvelope
  delete: [AgreementWhereUniqueInput!]
  deleteMany: [AgreementScalarWhereInput!]
  disconnect: [AgreementWhereUniqueInput!]
  set: [AgreementWhereUniqueInput!]
  update: [AgreementUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [AgreementUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [AgreementUpsertWithWhereUniqueWithoutCustomerInput!]
}

input AgreementUpdateWithWhereUniqueWithoutCustomerInput {
  data: AgreementUpdateWithoutCustomerInput!
  where: AgreementWhereUniqueInput!
}

input AgreementUpdateWithoutCustomerInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AgreementUpsertWithWhereUniqueWithoutCustomerInput {
  create: AgreementCreateWithoutCustomerInput!
  update: AgreementUpdateWithoutCustomerInput!
  where: AgreementWhereUniqueInput!
}

input AgreementWhereInput {
  AND: [AgreementWhereInput!]
  NOT: [AgreementWhereInput!]
  OR: [AgreementWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  description: StringFilter
  id: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AgreementWhereUniqueInput {
  AND: [AgreementWhereInput!]
  NOT: [AgreementWhereInput!]
  OR: [AgreementWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  description: StringFilter
  id: Int
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Avatar {
  contact: Contact!
  contactId: Int!
  id: ID!
  src: String!
  title: String!
}

input AvatarCreateNestedOneWithoutContactInput {
  connect: AvatarWhereUniqueInput
  connectOrCreate: AvatarCreateOrConnectWithoutContactInput
  create: AvatarCreateWithoutContactInput
}

input AvatarCreateOrConnectWithoutContactInput {
  create: AvatarCreateWithoutContactInput!
  where: AvatarWhereUniqueInput!
}

input AvatarCreateWithoutContactInput {
  src: String!
  title: String!
}

input AvatarNullableRelationFilter {
  is: AvatarWhereInput
  isNot: AvatarWhereInput
}

input AvatarOrderByWithRelationInput {
  contact: ContactOrderByWithRelationInput
  contactId: SortOrder
  id: SortOrder
  src: SortOrder
  title: SortOrder
}

input AvatarUpdateOneWithoutContactNestedInput {
  connect: AvatarWhereUniqueInput
  connectOrCreate: AvatarCreateOrConnectWithoutContactInput
  create: AvatarCreateWithoutContactInput
  delete: AvatarWhereInput
  disconnect: AvatarWhereInput
  update: AvatarUpdateToOneWithWhereWithoutContactInput
  upsert: AvatarUpsertWithoutContactInput
}

input AvatarUpdateToOneWithWhereWithoutContactInput {
  data: AvatarUpdateWithoutContactInput!
  where: AvatarWhereInput
}

input AvatarUpdateWithoutContactInput {
  src: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input AvatarUpsertWithoutContactInput {
  create: AvatarCreateWithoutContactInput!
  update: AvatarUpdateWithoutContactInput!
  where: AvatarWhereInput
}

input AvatarWhereInput {
  AND: [AvatarWhereInput!]
  NOT: [AvatarWhereInput!]
  OR: [AvatarWhereInput!]
  contact: ContactRelationFilter
  contactId: IntFilter
  id: IntFilter
  src: StringFilter
  title: StringFilter
}

input AvatarWhereUniqueInput {
  AND: [AvatarWhereInput!]
  NOT: [AvatarWhereInput!]
  OR: [AvatarWhereInput!]
  contact: ContactRelationFilter
  contactId: Int
  id: Int
  src: StringFilter
  title: StringFilter
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

enum CompanyStatus {
  ACTIVE
  HOLD
  INACTIVE
  NEW
  ONBOARDING
}

type Contact {
  avatar: Avatar
  createdAt: DateTime!
  customer: Customer!
  customerId: Int!
  designation: String
  email: String!
  firstName: String!
  gender: Gender!
  id: ID!
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime!
}

type ContactAvgAggregate {
  customerId: Float
  id: Float
}

input ContactAvgAggregateInput {
  customerId: Boolean
  id: Boolean
}

input ContactAvgOrderByAggregateInput {
  customerId: SortOrder
  id: SortOrder
}

type ContactCountAggregate {
  _all: Int!
  createdAt: Int!
  customerId: Int!
  designation: Int!
  email: Int!
  firstName: Int!
  gender: Int!
  id: Int!
  isPrimary: Int!
  lastName: Int!
  middleName: Int!
  phone: Int!
  title: Int!
  updatedAt: Int!
}

input ContactCountAggregateInput {
  _all: Boolean
  createdAt: Boolean
  customerId: Boolean
  designation: Boolean
  email: Boolean
  firstName: Boolean
  gender: Boolean
  id: Boolean
  isPrimary: Boolean
  lastName: Boolean
  middleName: Boolean
  phone: Boolean
  title: Boolean
  updatedAt: Boolean
}

input ContactCountOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  designation: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  isPrimary: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  phone: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input ContactCreateInput {
  avatar: AvatarCreateNestedOneWithoutContactInput
  createdAt: DateTime
  customer: CustomerCreateNestedOneWithoutContactsInput!
  designation: String
  email: String!
  firstName: String!
  gender: Gender
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime
}

input ContactCreateManyCustomerInput {
  createdAt: DateTime
  designation: String
  email: String!
  firstName: String!
  gender: Gender
  id: Int
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime
}

input ContactCreateManyCustomerInputEnvelope {
  data: [ContactCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input ContactCreateManyInput {
  createdAt: DateTime
  customerId: Int!
  designation: String
  email: String!
  firstName: String!
  gender: Gender
  id: Int
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime
}

input ContactCreateNestedManyWithoutCustomerInput {
  connect: [ContactWhereUniqueInput!]
  connectOrCreate: [ContactCreateOrConnectWithoutCustomerInput!]
  create: [ContactCreateWithoutCustomerInput!]
  createMany: ContactCreateManyCustomerInputEnvelope
}

input ContactCreateOrConnectWithoutCustomerInput {
  create: ContactCreateWithoutCustomerInput!
  where: ContactWhereUniqueInput!
}

input ContactCreateWithoutCustomerInput {
  avatar: AvatarCreateNestedOneWithoutContactInput
  createdAt: DateTime
  designation: String
  email: String!
  firstName: String!
  gender: Gender
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime
}

type ContactGroupBy {
  _avg: ContactAvgAggregate
  _count: ContactCountAggregate
  _max: ContactMaxAggregate
  _min: ContactMinAggregate
  _sum: ContactSumAggregate
  createdAt: DateTime!
  customerId: Int!
  designation: String
  email: String!
  firstName: String!
  gender: Gender!
  id: Int!
  isPrimary: Boolean!
  lastName: String!
  middleName: String
  phone: String
  title: String!
  updatedAt: DateTime!
}

input ContactListRelationFilter {
  every: ContactWhereInput
  none: ContactWhereInput
  some: ContactWhereInput
}

type ContactMaxAggregate {
  createdAt: DateTime
  customerId: Int
  designation: String
  email: String
  firstName: String
  gender: Gender
  id: Int
  isPrimary: Boolean
  lastName: String
  middleName: String
  phone: String
  title: String
  updatedAt: DateTime
}

input ContactMaxAggregateInput {
  createdAt: Boolean
  customerId: Boolean
  designation: Boolean
  email: Boolean
  firstName: Boolean
  gender: Boolean
  id: Boolean
  isPrimary: Boolean
  lastName: Boolean
  middleName: Boolean
  phone: Boolean
  title: Boolean
  updatedAt: Boolean
}

input ContactMaxOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  designation: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  isPrimary: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  phone: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type ContactMinAggregate {
  createdAt: DateTime
  customerId: Int
  designation: String
  email: String
  firstName: String
  gender: Gender
  id: Int
  isPrimary: Boolean
  lastName: String
  middleName: String
  phone: String
  title: String
  updatedAt: DateTime
}

input ContactMinAggregateInput {
  createdAt: Boolean
  customerId: Boolean
  designation: Boolean
  email: Boolean
  firstName: Boolean
  gender: Boolean
  id: Boolean
  isPrimary: Boolean
  lastName: Boolean
  middleName: Boolean
  phone: Boolean
  title: Boolean
  updatedAt: Boolean
}

input ContactMinOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  designation: SortOrder
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  isPrimary: SortOrder
  lastName: SortOrder
  middleName: SortOrder
  phone: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input ContactOrderByRelationAggregateInput {
  _count: SortOrder
}

input ContactOrderByWithAggregationInput {
  _avg: ContactAvgOrderByAggregateInput
  _count: ContactCountOrderByAggregateInput
  _max: ContactMaxOrderByAggregateInput
  _min: ContactMinOrderByAggregateInput
  _sum: ContactSumOrderByAggregateInput
  createdAt: SortOrder
  customerId: SortOrder
  designation: SortOrderInput
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  isPrimary: SortOrder
  lastName: SortOrder
  middleName: SortOrderInput
  phone: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input ContactOrderByWithRelationInput {
  avatar: AvatarOrderByWithRelationInput
  createdAt: SortOrder
  customer: CustomerOrderByWithRelationInput
  customerId: SortOrder
  designation: SortOrderInput
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  isPrimary: SortOrder
  lastName: SortOrder
  middleName: SortOrderInput
  phone: SortOrderInput
  title: SortOrder
  updatedAt: SortOrder
}

input ContactRelationFilter {
  is: ContactWhereInput
  isNot: ContactWhereInput
}

enum ContactScalarFieldEnum {
  createdAt
  customerId
  designation
  email
  firstName
  gender
  id
  isPrimary
  lastName
  middleName
  phone
  title
  updatedAt
}

input ContactScalarWhereInput {
  AND: [ContactScalarWhereInput!]
  NOT: [ContactScalarWhereInput!]
  OR: [ContactScalarWhereInput!]
  createdAt: DateTimeFilter
  customerId: IntFilter
  designation: StringNullableFilter
  email: StringFilter
  firstName: StringFilter
  gender: EnumGenderFilter
  id: IntFilter
  isPrimary: BoolFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  phone: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input ContactScalarWhereWithAggregatesInput {
  AND: [ContactScalarWhereWithAggregatesInput!]
  NOT: [ContactScalarWhereWithAggregatesInput!]
  OR: [ContactScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  customerId: IntWithAggregatesFilter
  designation: StringNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: EnumGenderWithAggregatesFilter
  id: IntWithAggregatesFilter
  isPrimary: BoolWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  middleName: StringNullableWithAggregatesFilter
  phone: StringNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ContactSumAggregate {
  customerId: Int
  id: Int
}

input ContactSumAggregateInput {
  customerId: Boolean
  id: Boolean
}

input ContactSumOrderByAggregateInput {
  customerId: SortOrder
  id: SortOrder
}

input ContactUpdateInput {
  avatar: AvatarUpdateOneWithoutContactNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutContactsNestedInput
  designation: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  isPrimary: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ContactUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  designation: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  isPrimary: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ContactUpdateManyWithWhereWithoutCustomerInput {
  data: ContactUpdateManyMutationInput!
  where: ContactScalarWhereInput!
}

input ContactUpdateManyWithoutCustomerNestedInput {
  connect: [ContactWhereUniqueInput!]
  connectOrCreate: [ContactCreateOrConnectWithoutCustomerInput!]
  create: [ContactCreateWithoutCustomerInput!]
  createMany: ContactCreateManyCustomerInputEnvelope
  delete: [ContactWhereUniqueInput!]
  deleteMany: [ContactScalarWhereInput!]
  disconnect: [ContactWhereUniqueInput!]
  set: [ContactWhereUniqueInput!]
  update: [ContactUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [ContactUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [ContactUpsertWithWhereUniqueWithoutCustomerInput!]
}

input ContactUpdateWithWhereUniqueWithoutCustomerInput {
  data: ContactUpdateWithoutCustomerInput!
  where: ContactWhereUniqueInput!
}

input ContactUpdateWithoutCustomerInput {
  avatar: AvatarUpdateOneWithoutContactNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  designation: NullableStringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  isPrimary: BoolFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  middleName: NullableStringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ContactUpsertWithWhereUniqueWithoutCustomerInput {
  create: ContactCreateWithoutCustomerInput!
  update: ContactUpdateWithoutCustomerInput!
  where: ContactWhereUniqueInput!
}

input ContactWhereInput {
  AND: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  avatar: AvatarNullableRelationFilter
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  designation: StringNullableFilter
  email: StringFilter
  firstName: StringFilter
  gender: EnumGenderFilter
  id: IntFilter
  isPrimary: BoolFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  phone: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input ContactWhereUniqueInput {
  AND: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  avatar: AvatarNullableRelationFilter
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  designation: StringNullableFilter
  email: String
  firstName: StringFilter
  gender: EnumGenderFilter
  id: Int
  isPrimary: BoolFilter
  lastName: StringFilter
  middleName: StringNullableFilter
  phone: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Customer {
  _count: CustomerCount!
  address: String
  addresses: [Address!]
  agreements: [Agreement!]
  city: String
  company: String!
  contacts: [Contact!]
  country: String
  createdAt: DateTime!
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchy: Hierarchy
  hierarchyId: Int
  id: ID!
  industry: String
  linkedinUrl: String!
  logo: Logo
  name: String!
  organization: Organization!
  organizationId: Int!
  phone: String
  revenue: String
  services: [Service!]
  size: String
  status: CompanyStatus!
  taxIdentifier: String
  updatedAt: DateTime!
  website: String
  zipcode: String
}

type CustomerAvgAggregate {
  hierarchyId: Float
  id: Float
  organizationId: Float
}

input CustomerAvgAggregateInput {
  hierarchyId: Boolean
  id: Boolean
  organizationId: Boolean
}

input CustomerAvgOrderByAggregateInput {
  hierarchyId: SortOrder
  id: SortOrder
  organizationId: SortOrder
}

type CustomerCount {
  addresses: Int!
  agreements: Int!
  contacts: Int!
  services: Int!
}

type CustomerCountAggregate {
  _all: Int!
  address: Int!
  city: Int!
  company: Int!
  country: Int!
  createdAt: Int!
  description: Int!
  domain: Int!
  email: Int!
  founded: Int!
  hierarchyId: Int!
  id: Int!
  industry: Int!
  linkedinUrl: Int!
  name: Int!
  organizationId: Int!
  phone: Int!
  revenue: Int!
  size: Int!
  status: Int!
  taxIdentifier: Int!
  updatedAt: Int!
  website: Int!
  zipcode: Int!
}

input CustomerCountAggregateInput {
  _all: Boolean
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  founded: Boolean
  hierarchyId: Boolean
  id: Boolean
  industry: Boolean
  linkedinUrl: Boolean
  name: Boolean
  organizationId: Boolean
  phone: Boolean
  revenue: Boolean
  size: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input CustomerCountOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  founded: SortOrder
  hierarchyId: SortOrder
  id: SortOrder
  industry: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  organizationId: SortOrder
  phone: SortOrder
  revenue: SortOrder
  size: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

input CustomerCreateInput {
  address: String
  addresses: AddressCreateNestedManyWithoutCustomerInput
  agreements: AgreementCreateNestedManyWithoutCustomerInput
  city: String
  company: String!
  contacts: ContactCreateNestedManyWithoutCustomerInput
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchy: HierarchyCreateNestedOneWithoutCustomersInput
  industry: String
  linkedinUrl: String!
  logo: LogoCreateNestedOneWithoutCustomerInput
  name: String!
  organization: OrganizationCreateNestedOneWithoutCustomersInput!
  phone: String
  revenue: String
  services: ServiceCreateNestedManyWithoutCustomerInput
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateManyHierarchyInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  id: Int
  industry: String
  linkedinUrl: String!
  name: String!
  organizationId: Int!
  phone: String
  revenue: String
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateManyHierarchyInputEnvelope {
  data: [CustomerCreateManyHierarchyInput!]!
  skipDuplicates: Boolean
}

input CustomerCreateManyInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchyId: Int
  id: Int
  industry: String
  linkedinUrl: String!
  name: String!
  organizationId: Int!
  phone: String
  revenue: String
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateManyOrganizationInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchyId: Int
  id: Int
  industry: String
  linkedinUrl: String!
  name: String!
  phone: String
  revenue: String
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateManyOrganizationInputEnvelope {
  data: [CustomerCreateManyOrganizationInput!]!
  skipDuplicates: Boolean
}

input CustomerCreateNestedManyWithoutHierarchyInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutHierarchyInput!]
  create: [CustomerCreateWithoutHierarchyInput!]
  createMany: CustomerCreateManyHierarchyInputEnvelope
}

input CustomerCreateNestedManyWithoutOrganizationInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutOrganizationInput!]
  create: [CustomerCreateWithoutOrganizationInput!]
  createMany: CustomerCreateManyOrganizationInputEnvelope
}

input CustomerCreateNestedOneWithoutContactsInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutContactsInput
  create: CustomerCreateWithoutContactsInput
}

input CustomerCreateOrConnectWithoutContactsInput {
  create: CustomerCreateWithoutContactsInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutHierarchyInput {
  create: CustomerCreateWithoutHierarchyInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutOrganizationInput {
  create: CustomerCreateWithoutOrganizationInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutContactsInput {
  address: String
  addresses: AddressCreateNestedManyWithoutCustomerInput
  agreements: AgreementCreateNestedManyWithoutCustomerInput
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchy: HierarchyCreateNestedOneWithoutCustomersInput
  industry: String
  linkedinUrl: String!
  logo: LogoCreateNestedOneWithoutCustomerInput
  name: String!
  organization: OrganizationCreateNestedOneWithoutCustomersInput!
  phone: String
  revenue: String
  services: ServiceCreateNestedManyWithoutCustomerInput
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateWithoutHierarchyInput {
  address: String
  addresses: AddressCreateNestedManyWithoutCustomerInput
  agreements: AgreementCreateNestedManyWithoutCustomerInput
  city: String
  company: String!
  contacts: ContactCreateNestedManyWithoutCustomerInput
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  industry: String
  linkedinUrl: String!
  logo: LogoCreateNestedOneWithoutCustomerInput
  name: String!
  organization: OrganizationCreateNestedOneWithoutCustomersInput!
  phone: String
  revenue: String
  services: ServiceCreateNestedManyWithoutCustomerInput
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerCreateWithoutOrganizationInput {
  address: String
  addresses: AddressCreateNestedManyWithoutCustomerInput
  agreements: AgreementCreateNestedManyWithoutCustomerInput
  city: String
  company: String!
  contacts: ContactCreateNestedManyWithoutCustomerInput
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchy: HierarchyCreateNestedOneWithoutCustomersInput
  industry: String
  linkedinUrl: String!
  logo: LogoCreateNestedOneWithoutCustomerInput
  name: String!
  phone: String
  revenue: String
  services: ServiceCreateNestedManyWithoutCustomerInput
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

type CustomerGroupBy {
  _avg: CustomerAvgAggregate
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  _sum: CustomerSumAggregate
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime!
  description: String
  domain: String!
  email: String!
  founded: String
  hierarchyId: Int
  id: Int!
  industry: String
  linkedinUrl: String!
  name: String!
  organizationId: Int!
  phone: String
  revenue: String
  size: String
  status: CompanyStatus!
  taxIdentifier: String
  updatedAt: DateTime!
  website: String
  zipcode: String
}

input CustomerListRelationFilter {
  every: CustomerWhereInput
  none: CustomerWhereInput
  some: CustomerWhereInput
}

type CustomerMaxAggregate {
  address: String
  city: String
  company: String
  country: String
  createdAt: DateTime
  description: String
  domain: String
  email: String
  founded: String
  hierarchyId: Int
  id: Int
  industry: String
  linkedinUrl: String
  name: String
  organizationId: Int
  phone: String
  revenue: String
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerMaxAggregateInput {
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  founded: Boolean
  hierarchyId: Boolean
  id: Boolean
  industry: Boolean
  linkedinUrl: Boolean
  name: Boolean
  organizationId: Boolean
  phone: Boolean
  revenue: Boolean
  size: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input CustomerMaxOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  founded: SortOrder
  hierarchyId: SortOrder
  id: SortOrder
  industry: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  organizationId: SortOrder
  phone: SortOrder
  revenue: SortOrder
  size: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

type CustomerMinAggregate {
  address: String
  city: String
  company: String
  country: String
  createdAt: DateTime
  description: String
  domain: String
  email: String
  founded: String
  hierarchyId: Int
  id: Int
  industry: String
  linkedinUrl: String
  name: String
  organizationId: Int
  phone: String
  revenue: String
  size: String
  status: CompanyStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input CustomerMinAggregateInput {
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  founded: Boolean
  hierarchyId: Boolean
  id: Boolean
  industry: Boolean
  linkedinUrl: Boolean
  name: Boolean
  organizationId: Boolean
  phone: Boolean
  revenue: Boolean
  size: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input CustomerMinOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  founded: SortOrder
  hierarchyId: SortOrder
  id: SortOrder
  industry: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  organizationId: SortOrder
  phone: SortOrder
  revenue: SortOrder
  size: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

input CustomerOrderByRelationAggregateInput {
  _count: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _avg: CustomerAvgOrderByAggregateInput
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  _sum: CustomerSumOrderByAggregateInput
  address: SortOrderInput
  city: SortOrderInput
  company: SortOrder
  country: SortOrderInput
  createdAt: SortOrder
  description: SortOrderInput
  domain: SortOrder
  email: SortOrder
  founded: SortOrderInput
  hierarchyId: SortOrderInput
  id: SortOrder
  industry: SortOrderInput
  linkedinUrl: SortOrder
  name: SortOrder
  organizationId: SortOrder
  phone: SortOrderInput
  revenue: SortOrderInput
  size: SortOrderInput
  status: SortOrder
  taxIdentifier: SortOrderInput
  updatedAt: SortOrder
  website: SortOrderInput
  zipcode: SortOrderInput
}

input CustomerOrderByWithRelationInput {
  address: SortOrderInput
  addresses: AddressOrderByRelationAggregateInput
  agreements: AgreementOrderByRelationAggregateInput
  city: SortOrderInput
  company: SortOrder
  contacts: ContactOrderByRelationAggregateInput
  country: SortOrderInput
  createdAt: SortOrder
  description: SortOrderInput
  domain: SortOrder
  email: SortOrder
  founded: SortOrderInput
  hierarchy: HierarchyOrderByWithRelationInput
  hierarchyId: SortOrderInput
  id: SortOrder
  industry: SortOrderInput
  linkedinUrl: SortOrder
  logo: LogoOrderByWithRelationInput
  name: SortOrder
  organization: OrganizationOrderByWithRelationInput
  organizationId: SortOrder
  phone: SortOrderInput
  revenue: SortOrderInput
  services: ServiceOrderByRelationAggregateInput
  size: SortOrderInput
  status: SortOrder
  taxIdentifier: SortOrderInput
  updatedAt: SortOrder
  website: SortOrderInput
  zipcode: SortOrderInput
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  address
  city
  company
  country
  createdAt
  description
  domain
  email
  founded
  hierarchyId
  id
  industry
  linkedinUrl
  name
  organizationId
  phone
  revenue
  size
  status
  taxIdentifier
  updatedAt
  website
  zipcode
}

input CustomerScalarWhereInput {
  AND: [CustomerScalarWhereInput!]
  NOT: [CustomerScalarWhereInput!]
  OR: [CustomerScalarWhereInput!]
  address: StringNullableFilter
  city: StringNullableFilter
  company: StringFilter
  country: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  domain: StringFilter
  email: StringFilter
  founded: StringNullableFilter
  hierarchyId: IntNullableFilter
  id: IntFilter
  industry: StringNullableFilter
  linkedinUrl: StringFilter
  name: StringFilter
  organizationId: IntFilter
  phone: StringNullableFilter
  revenue: StringNullableFilter
  size: StringNullableFilter
  status: EnumCompanyStatusFilter
  taxIdentifier: StringNullableFilter
  updatedAt: DateTimeFilter
  website: StringNullableFilter
  zipcode: StringNullableFilter
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  city: StringNullableWithAggregatesFilter
  company: StringWithAggregatesFilter
  country: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  domain: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  founded: StringNullableWithAggregatesFilter
  hierarchyId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  industry: StringNullableWithAggregatesFilter
  linkedinUrl: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  organizationId: IntWithAggregatesFilter
  phone: StringNullableWithAggregatesFilter
  revenue: StringNullableWithAggregatesFilter
  size: StringNullableWithAggregatesFilter
  status: EnumCompanyStatusWithAggregatesFilter
  taxIdentifier: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  website: StringNullableWithAggregatesFilter
  zipcode: StringNullableWithAggregatesFilter
}

type CustomerSumAggregate {
  hierarchyId: Int
  id: Int
  organizationId: Int
}

input CustomerSumAggregateInput {
  hierarchyId: Boolean
  id: Boolean
  organizationId: Boolean
}

input CustomerSumOrderByAggregateInput {
  hierarchyId: SortOrder
  id: SortOrder
  organizationId: SortOrder
}

input CustomerUpdateInput {
  address: NullableStringFieldUpdateOperationsInput
  addresses: AddressUpdateManyWithoutCustomerNestedInput
  agreements: AgreementUpdateManyWithoutCustomerNestedInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  contacts: ContactUpdateManyWithoutCustomerNestedInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  founded: NullableStringFieldUpdateOperationsInput
  hierarchy: HierarchyUpdateOneWithoutCustomersNestedInput
  industry: NullableStringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: LogoUpdateOneWithoutCustomerNestedInput
  name: StringFieldUpdateOperationsInput
  organization: OrganizationUpdateOneRequiredWithoutCustomersNestedInput
  phone: NullableStringFieldUpdateOperationsInput
  revenue: NullableStringFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutCustomerNestedInput
  size: NullableStringFieldUpdateOperationsInput
  status: EnumCompanyStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  founded: NullableStringFieldUpdateOperationsInput
  industry: NullableStringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  revenue: NullableStringFieldUpdateOperationsInput
  size: NullableStringFieldUpdateOperationsInput
  status: EnumCompanyStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateManyWithWhereWithoutHierarchyInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithWhereWithoutOrganizationInput {
  data: CustomerUpdateManyMutationInput!
  where: CustomerScalarWhereInput!
}

input CustomerUpdateManyWithoutHierarchyNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutHierarchyInput!]
  create: [CustomerCreateWithoutHierarchyInput!]
  createMany: CustomerCreateManyHierarchyInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutHierarchyInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutHierarchyInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutHierarchyInput!]
}

input CustomerUpdateManyWithoutOrganizationNestedInput {
  connect: [CustomerWhereUniqueInput!]
  connectOrCreate: [CustomerCreateOrConnectWithoutOrganizationInput!]
  create: [CustomerCreateWithoutOrganizationInput!]
  createMany: CustomerCreateManyOrganizationInputEnvelope
  delete: [CustomerWhereUniqueInput!]
  deleteMany: [CustomerScalarWhereInput!]
  disconnect: [CustomerWhereUniqueInput!]
  set: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutOrganizationInput!]
  updateMany: [CustomerUpdateManyWithWhereWithoutOrganizationInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutOrganizationInput!]
}

input CustomerUpdateOneRequiredWithoutContactsNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutContactsInput
  create: CustomerCreateWithoutContactsInput
  update: CustomerUpdateToOneWithWhereWithoutContactsInput
  upsert: CustomerUpsertWithoutContactsInput
}

input CustomerUpdateToOneWithWhereWithoutContactsInput {
  data: CustomerUpdateWithoutContactsInput!
  where: CustomerWhereInput
}

input CustomerUpdateWithWhereUniqueWithoutHierarchyInput {
  data: CustomerUpdateWithoutHierarchyInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithWhereUniqueWithoutOrganizationInput {
  data: CustomerUpdateWithoutOrganizationInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpdateWithoutContactsInput {
  address: NullableStringFieldUpdateOperationsInput
  addresses: AddressUpdateManyWithoutCustomerNestedInput
  agreements: AgreementUpdateManyWithoutCustomerNestedInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  founded: NullableStringFieldUpdateOperationsInput
  hierarchy: HierarchyUpdateOneWithoutCustomersNestedInput
  industry: NullableStringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: LogoUpdateOneWithoutCustomerNestedInput
  name: StringFieldUpdateOperationsInput
  organization: OrganizationUpdateOneRequiredWithoutCustomersNestedInput
  phone: NullableStringFieldUpdateOperationsInput
  revenue: NullableStringFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutCustomerNestedInput
  size: NullableStringFieldUpdateOperationsInput
  status: EnumCompanyStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithoutHierarchyInput {
  address: NullableStringFieldUpdateOperationsInput
  addresses: AddressUpdateManyWithoutCustomerNestedInput
  agreements: AgreementUpdateManyWithoutCustomerNestedInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  contacts: ContactUpdateManyWithoutCustomerNestedInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  founded: NullableStringFieldUpdateOperationsInput
  industry: NullableStringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: LogoUpdateOneWithoutCustomerNestedInput
  name: StringFieldUpdateOperationsInput
  organization: OrganizationUpdateOneRequiredWithoutCustomersNestedInput
  phone: NullableStringFieldUpdateOperationsInput
  revenue: NullableStringFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutCustomerNestedInput
  size: NullableStringFieldUpdateOperationsInput
  status: EnumCompanyStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input CustomerUpdateWithoutOrganizationInput {
  address: NullableStringFieldUpdateOperationsInput
  addresses: AddressUpdateManyWithoutCustomerNestedInput
  agreements: AgreementUpdateManyWithoutCustomerNestedInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  contacts: ContactUpdateManyWithoutCustomerNestedInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  founded: NullableStringFieldUpdateOperationsInput
  hierarchy: HierarchyUpdateOneWithoutCustomersNestedInput
  industry: NullableStringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: LogoUpdateOneWithoutCustomerNestedInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  revenue: NullableStringFieldUpdateOperationsInput
  services: ServiceUpdateManyWithoutCustomerNestedInput
  size: NullableStringFieldUpdateOperationsInput
  status: EnumCompanyStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input CustomerUpsertWithWhereUniqueWithoutHierarchyInput {
  create: CustomerCreateWithoutHierarchyInput!
  update: CustomerUpdateWithoutHierarchyInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithWhereUniqueWithoutOrganizationInput {
  create: CustomerCreateWithoutOrganizationInput!
  update: CustomerUpdateWithoutOrganizationInput!
  where: CustomerWhereUniqueInput!
}

input CustomerUpsertWithoutContactsInput {
  create: CustomerCreateWithoutContactsInput!
  update: CustomerUpdateWithoutContactsInput!
  where: CustomerWhereInput
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringNullableFilter
  addresses: AddressListRelationFilter
  agreements: AgreementListRelationFilter
  city: StringNullableFilter
  company: StringFilter
  contacts: ContactListRelationFilter
  country: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  domain: StringFilter
  email: StringFilter
  founded: StringNullableFilter
  hierarchy: HierarchyNullableRelationFilter
  hierarchyId: IntNullableFilter
  id: IntFilter
  industry: StringNullableFilter
  linkedinUrl: StringFilter
  logo: LogoNullableRelationFilter
  name: StringFilter
  organization: OrganizationRelationFilter
  organizationId: IntFilter
  phone: StringNullableFilter
  revenue: StringNullableFilter
  services: ServiceListRelationFilter
  size: StringNullableFilter
  status: EnumCompanyStatusFilter
  taxIdentifier: StringNullableFilter
  updatedAt: DateTimeFilter
  website: StringNullableFilter
  zipcode: StringNullableFilter
}

input CustomerWhereUniqueInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringNullableFilter
  addresses: AddressListRelationFilter
  agreements: AgreementListRelationFilter
  city: StringNullableFilter
  company: StringFilter
  contacts: ContactListRelationFilter
  country: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  domain: StringFilter
  email: String
  founded: StringNullableFilter
  hierarchy: HierarchyNullableRelationFilter
  hierarchyId: IntNullableFilter
  id: Int
  industry: StringNullableFilter
  linkedinUrl: StringFilter
  logo: LogoNullableRelationFilter
  name: StringFilter
  organization: OrganizationRelationFilter
  organizationId: IntFilter
  phone: StringNullableFilter
  revenue: StringNullableFilter
  services: ServiceListRelationFilter
  size: StringNullableFilter
  status: EnumCompanyStatusFilter
  taxIdentifier: StringNullableFilter
  updatedAt: DateTimeFilter
  website: StringNullableFilter
  zipcode: StringNullableFilter
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumAgentTypeFieldUpdateOperationsInput {
  set: AgentType
}

input EnumAgentTypeFilter {
  equals: AgentType
  in: [AgentType!]
  not: NestedEnumAgentTypeFilter
  notIn: [AgentType!]
}

input EnumCompanyStatusFieldUpdateOperationsInput {
  set: CompanyStatus
}

input EnumCompanyStatusFilter {
  equals: CompanyStatus
  in: [CompanyStatus!]
  not: NestedEnumCompanyStatusFilter
  notIn: [CompanyStatus!]
}

input EnumCompanyStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumCompanyStatusFilter
  _min: NestedEnumCompanyStatusFilter
  equals: CompanyStatus
  in: [CompanyStatus!]
  not: NestedEnumCompanyStatusWithAggregatesFilter
  notIn: [CompanyStatus!]
}

input EnumGenderFieldUpdateOperationsInput {
  set: Gender
}

input EnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input EnumGenderWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumGenderFilter
  _min: NestedEnumGenderFilter
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input EnumOranizationStatusFieldUpdateOperationsInput {
  set: OranizationStatus
}

input EnumOranizationStatusFilter {
  equals: OranizationStatus
  in: [OranizationStatus!]
  not: NestedEnumOranizationStatusFilter
  notIn: [OranizationStatus!]
}

input EnumOranizationStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOranizationStatusFilter
  _min: NestedEnumOranizationStatusFilter
  equals: OranizationStatus
  in: [OranizationStatus!]
  not: NestedEnumOranizationStatusWithAggregatesFilter
  notIn: [OranizationStatus!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

enum Gender {
  FEMALE
  MALE
  NOTMENTIONED
}

type Hierarchy {
  _count: HierarchyCount!
  children: [Hierarchy!]
  createdAt: DateTime!
  customers: [Customer!]
  id: ID!
  level: String!
  parent: Hierarchy
  parentId: Int
  updatedAt: DateTime!
}

type HierarchyCount {
  children: Int!
  customers: Int!
}

input HierarchyCreateManyParentInput {
  createdAt: DateTime
  id: Int
  level: String!
  updatedAt: DateTime
}

input HierarchyCreateManyParentInputEnvelope {
  data: [HierarchyCreateManyParentInput!]!
  skipDuplicates: Boolean
}

input HierarchyCreateNestedManyWithoutParentInput {
  connect: [HierarchyWhereUniqueInput!]
  connectOrCreate: [HierarchyCreateOrConnectWithoutParentInput!]
  create: [HierarchyCreateWithoutParentInput!]
  createMany: HierarchyCreateManyParentInputEnvelope
}

input HierarchyCreateNestedOneWithoutChildrenInput {
  connect: HierarchyWhereUniqueInput
  connectOrCreate: HierarchyCreateOrConnectWithoutChildrenInput
  create: HierarchyCreateWithoutChildrenInput
}

input HierarchyCreateNestedOneWithoutCustomersInput {
  connect: HierarchyWhereUniqueInput
  connectOrCreate: HierarchyCreateOrConnectWithoutCustomersInput
  create: HierarchyCreateWithoutCustomersInput
}

input HierarchyCreateOrConnectWithoutChildrenInput {
  create: HierarchyCreateWithoutChildrenInput!
  where: HierarchyWhereUniqueInput!
}

input HierarchyCreateOrConnectWithoutCustomersInput {
  create: HierarchyCreateWithoutCustomersInput!
  where: HierarchyWhereUniqueInput!
}

input HierarchyCreateOrConnectWithoutParentInput {
  create: HierarchyCreateWithoutParentInput!
  where: HierarchyWhereUniqueInput!
}

input HierarchyCreateWithoutChildrenInput {
  createdAt: DateTime
  customers: CustomerCreateNestedManyWithoutHierarchyInput
  level: String!
  parent: HierarchyCreateNestedOneWithoutChildrenInput
  updatedAt: DateTime
}

input HierarchyCreateWithoutCustomersInput {
  children: HierarchyCreateNestedManyWithoutParentInput
  createdAt: DateTime
  level: String!
  parent: HierarchyCreateNestedOneWithoutChildrenInput
  updatedAt: DateTime
}

input HierarchyCreateWithoutParentInput {
  children: HierarchyCreateNestedManyWithoutParentInput
  createdAt: DateTime
  customers: CustomerCreateNestedManyWithoutHierarchyInput
  level: String!
  updatedAt: DateTime
}

input HierarchyListRelationFilter {
  every: HierarchyWhereInput
  none: HierarchyWhereInput
  some: HierarchyWhereInput
}

input HierarchyNullableRelationFilter {
  is: HierarchyWhereInput
  isNot: HierarchyWhereInput
}

input HierarchyOrderByRelationAggregateInput {
  _count: SortOrder
}

input HierarchyOrderByWithRelationInput {
  children: HierarchyOrderByRelationAggregateInput
  createdAt: SortOrder
  customers: CustomerOrderByRelationAggregateInput
  id: SortOrder
  level: SortOrder
  parent: HierarchyOrderByWithRelationInput
  parentId: SortOrderInput
  updatedAt: SortOrder
}

input HierarchyScalarWhereInput {
  AND: [HierarchyScalarWhereInput!]
  NOT: [HierarchyScalarWhereInput!]
  OR: [HierarchyScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  level: StringFilter
  parentId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input HierarchyUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  level: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HierarchyUpdateManyWithWhereWithoutParentInput {
  data: HierarchyUpdateManyMutationInput!
  where: HierarchyScalarWhereInput!
}

input HierarchyUpdateManyWithoutParentNestedInput {
  connect: [HierarchyWhereUniqueInput!]
  connectOrCreate: [HierarchyCreateOrConnectWithoutParentInput!]
  create: [HierarchyCreateWithoutParentInput!]
  createMany: HierarchyCreateManyParentInputEnvelope
  delete: [HierarchyWhereUniqueInput!]
  deleteMany: [HierarchyScalarWhereInput!]
  disconnect: [HierarchyWhereUniqueInput!]
  set: [HierarchyWhereUniqueInput!]
  update: [HierarchyUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [HierarchyUpdateManyWithWhereWithoutParentInput!]
  upsert: [HierarchyUpsertWithWhereUniqueWithoutParentInput!]
}

input HierarchyUpdateOneWithoutChildrenNestedInput {
  connect: HierarchyWhereUniqueInput
  connectOrCreate: HierarchyCreateOrConnectWithoutChildrenInput
  create: HierarchyCreateWithoutChildrenInput
  delete: HierarchyWhereInput
  disconnect: HierarchyWhereInput
  update: HierarchyUpdateToOneWithWhereWithoutChildrenInput
  upsert: HierarchyUpsertWithoutChildrenInput
}

input HierarchyUpdateOneWithoutCustomersNestedInput {
  connect: HierarchyWhereUniqueInput
  connectOrCreate: HierarchyCreateOrConnectWithoutCustomersInput
  create: HierarchyCreateWithoutCustomersInput
  delete: HierarchyWhereInput
  disconnect: HierarchyWhereInput
  update: HierarchyUpdateToOneWithWhereWithoutCustomersInput
  upsert: HierarchyUpsertWithoutCustomersInput
}

input HierarchyUpdateToOneWithWhereWithoutChildrenInput {
  data: HierarchyUpdateWithoutChildrenInput!
  where: HierarchyWhereInput
}

input HierarchyUpdateToOneWithWhereWithoutCustomersInput {
  data: HierarchyUpdateWithoutCustomersInput!
  where: HierarchyWhereInput
}

input HierarchyUpdateWithWhereUniqueWithoutParentInput {
  data: HierarchyUpdateWithoutParentInput!
  where: HierarchyWhereUniqueInput!
}

input HierarchyUpdateWithoutChildrenInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  customers: CustomerUpdateManyWithoutHierarchyNestedInput
  level: StringFieldUpdateOperationsInput
  parent: HierarchyUpdateOneWithoutChildrenNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HierarchyUpdateWithoutCustomersInput {
  children: HierarchyUpdateManyWithoutParentNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  level: StringFieldUpdateOperationsInput
  parent: HierarchyUpdateOneWithoutChildrenNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HierarchyUpdateWithoutParentInput {
  children: HierarchyUpdateManyWithoutParentNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customers: CustomerUpdateManyWithoutHierarchyNestedInput
  level: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HierarchyUpsertWithWhereUniqueWithoutParentInput {
  create: HierarchyCreateWithoutParentInput!
  update: HierarchyUpdateWithoutParentInput!
  where: HierarchyWhereUniqueInput!
}

input HierarchyUpsertWithoutChildrenInput {
  create: HierarchyCreateWithoutChildrenInput!
  update: HierarchyUpdateWithoutChildrenInput!
  where: HierarchyWhereInput
}

input HierarchyUpsertWithoutCustomersInput {
  create: HierarchyCreateWithoutCustomersInput!
  update: HierarchyUpdateWithoutCustomersInput!
  where: HierarchyWhereInput
}

input HierarchyWhereInput {
  AND: [HierarchyWhereInput!]
  NOT: [HierarchyWhereInput!]
  OR: [HierarchyWhereInput!]
  children: HierarchyListRelationFilter
  createdAt: DateTimeFilter
  customers: CustomerListRelationFilter
  id: IntFilter
  level: StringFilter
  parent: HierarchyNullableRelationFilter
  parentId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input HierarchyWhereUniqueInput {
  AND: [HierarchyWhereInput!]
  NOT: [HierarchyWhereInput!]
  OR: [HierarchyWhereInput!]
  children: HierarchyListRelationFilter
  createdAt: DateTimeFilter
  customers: CustomerListRelationFilter
  id: Int
  level: StringFilter
  parent: HierarchyNullableRelationFilter
  parentId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input IncludeContactInput {
  avatar: Boolean
}

input IncludeCustomerInput {
  addresses: Boolean
  contacts: Boolean
  logo: Boolean
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Logo {
  customer: Customer!
  customerId: Int!
  id: ID!
  src: String!
  title: String!
}

input LogoCreateNestedOneWithoutCustomerInput {
  connect: LogoWhereUniqueInput
  connectOrCreate: LogoCreateOrConnectWithoutCustomerInput
  create: LogoCreateWithoutCustomerInput
}

input LogoCreateOrConnectWithoutCustomerInput {
  create: LogoCreateWithoutCustomerInput!
  where: LogoWhereUniqueInput!
}

input LogoCreateWithoutCustomerInput {
  src: String!
  title: String!
}

input LogoNullableRelationFilter {
  is: LogoWhereInput
  isNot: LogoWhereInput
}

input LogoOrderByWithRelationInput {
  customer: CustomerOrderByWithRelationInput
  customerId: SortOrder
  id: SortOrder
  src: SortOrder
  title: SortOrder
}

input LogoUpdateOneWithoutCustomerNestedInput {
  connect: LogoWhereUniqueInput
  connectOrCreate: LogoCreateOrConnectWithoutCustomerInput
  create: LogoCreateWithoutCustomerInput
  delete: LogoWhereInput
  disconnect: LogoWhereInput
  update: LogoUpdateToOneWithWhereWithoutCustomerInput
  upsert: LogoUpsertWithoutCustomerInput
}

input LogoUpdateToOneWithWhereWithoutCustomerInput {
  data: LogoUpdateWithoutCustomerInput!
  where: LogoWhereInput
}

input LogoUpdateWithoutCustomerInput {
  src: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input LogoUpsertWithoutCustomerInput {
  create: LogoCreateWithoutCustomerInput!
  update: LogoUpdateWithoutCustomerInput!
  where: LogoWhereInput
}

input LogoWhereInput {
  AND: [LogoWhereInput!]
  NOT: [LogoWhereInput!]
  OR: [LogoWhereInput!]
  customer: CustomerRelationFilter
  customerId: IntFilter
  id: IntFilter
  src: StringFilter
  title: StringFilter
}

input LogoWhereUniqueInput {
  AND: [LogoWhereInput!]
  NOT: [LogoWhereInput!]
  OR: [LogoWhereInput!]
  customer: CustomerRelationFilter
  customerId: Int
  id: Int
  src: StringFilter
  title: StringFilter
}

type Mutation {
  createAgentTerritory(
    data: AgentTerritoryCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): AgentTerritory
  createContact(
    data: ContactCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Contact
  createCustomer(
    data: CustomerCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Customer
  createManyAgentTerritory(
    data: [AgentTerritoryCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRows
  createManyContact(
    data: [ContactCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRows
  createManyCustomer(
    data: [CustomerCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRows
  createManyOrganization(
    data: [OrganizationCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRows
  createManyServiceTerritory(
    data: [ServiceTerritoryCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRows
  createOrganization(
    data: OrganizationCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Organization
  createServiceTerritory(
    data: ServiceTerritoryCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): ServiceTerritory
  deleteAgentTerritory(
    relationLoadStrategy: RelationLoadStrategy
    where: AgentTerritoryWhereUniqueInput!
  ): AgentTerritory
  deleteContact(
    relationLoadStrategy: RelationLoadStrategy
    where: ContactWhereUniqueInput!
  ): Contact
  deleteCustomer(
    relationLoadStrategy: RelationLoadStrategy
    where: CustomerWhereUniqueInput!
  ): Customer
  deleteManyAgentTerritory(where: AgentTerritoryWhereInput): AffectedRows
  deleteManyContact(where: ContactWhereInput): AffectedRows
  deleteManyCustomer(where: CustomerWhereInput): AffectedRows
  deleteManyOrganization(where: OrganizationWhereInput): AffectedRows
  deleteManyServiceTerritory(where: ServiceTerritoryWhereInput): AffectedRows
  deleteOrganization(
    relationLoadStrategy: RelationLoadStrategy
    where: OrganizationWhereUniqueInput!
  ): Organization
  deleteServiceTerritory(
    relationLoadStrategy: RelationLoadStrategy
    where: ServiceTerritoryWhereUniqueInput!
  ): ServiceTerritory
  updateAgentTerritory(
    data: AgentTerritoryUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
    where: AgentTerritoryWhereUniqueInput!
  ): AgentTerritory
  updateContact(
    data: ContactUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
    where: ContactWhereUniqueInput!
  ): Contact
  updateCustomer(
    data: CustomerUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
    where: CustomerWhereUniqueInput!
  ): Customer
  updateManyAgentTerritory(
    data: AgentTerritoryUncheckedUpdateManyInput!
    where: AgentTerritoryWhereInput
  ): AffectedRows
  updateManyContact(
    data: ContactUpdateManyMutationInput!
    where: ContactWhereInput
  ): AffectedRows
  updateManyCustomer(
    data: CustomerUpdateManyMutationInput!
    where: CustomerWhereInput
  ): AffectedRows
  updateManyOrganization(
    data: OrganizationUpdateManyMutationInput!
    where: OrganizationWhereInput
  ): AffectedRows
  updateManyServiceTerritory(
    data: ServiceTerritoryUpdateManyMutationInput!
    where: ServiceTerritoryWhereInput
  ): AffectedRows
  updateOrganization(
    data: OrganizationUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
    where: OrganizationWhereUniqueInput!
  ): Organization
  updateServiceTerritory(
    data: ServiceTerritoryUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
    where: ServiceTerritoryWhereUniqueInput!
  ): ServiceTerritory
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumAgentTypeFilter {
  equals: AgentType
  in: [AgentType!]
  not: NestedEnumAgentTypeFilter
  notIn: [AgentType!]
}

input NestedEnumCompanyStatusFilter {
  equals: CompanyStatus
  in: [CompanyStatus!]
  not: NestedEnumCompanyStatusFilter
  notIn: [CompanyStatus!]
}

input NestedEnumCompanyStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumCompanyStatusFilter
  _min: NestedEnumCompanyStatusFilter
  equals: CompanyStatus
  in: [CompanyStatus!]
  not: NestedEnumCompanyStatusWithAggregatesFilter
  notIn: [CompanyStatus!]
}

input NestedEnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input NestedEnumGenderWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumGenderFilter
  _min: NestedEnumGenderFilter
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input NestedEnumOranizationStatusFilter {
  equals: OranizationStatus
  in: [OranizationStatus!]
  not: NestedEnumOranizationStatusFilter
  notIn: [OranizationStatus!]
}

input NestedEnumOranizationStatusWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOranizationStatusFilter
  _min: NestedEnumOranizationStatusFilter
  equals: OranizationStatus
  in: [OranizationStatus!]
  not: NestedEnumOranizationStatusWithAggregatesFilter
  notIn: [OranizationStatus!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableFloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

enum OranizationStatus {
  ACTIVE
  HOLD
  INACTIVE
  NEW
  ONBOARDING
}

type Organization {
  _count: OrganizationCount!
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime!
  customers: [Customer!]
  description: String
  domain: String!
  email: String!
  id: ID!
  linkedinUrl: String!
  logo: OrganizationLogo
  name: String!
  phone: String
  status: OranizationStatus!
  taxIdentifier: String
  updatedAt: DateTime!
  website: String
  zipcode: String
}

type OrganizationAvgAggregate {
  id: Float
}

input OrganizationAvgAggregateInput {
  id: Boolean
}

input OrganizationAvgOrderByAggregateInput {
  id: SortOrder
}

type OrganizationCount {
  customers: Int!
}

type OrganizationCountAggregate {
  _all: Int!
  address: Int!
  city: Int!
  company: Int!
  country: Int!
  createdAt: Int!
  description: Int!
  domain: Int!
  email: Int!
  id: Int!
  linkedinUrl: Int!
  name: Int!
  phone: Int!
  status: Int!
  taxIdentifier: Int!
  updatedAt: Int!
  website: Int!
  zipcode: Int!
}

input OrganizationCountAggregateInput {
  _all: Boolean
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  id: Boolean
  linkedinUrl: Boolean
  name: Boolean
  phone: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input OrganizationCountOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  id: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  phone: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

input OrganizationCreateInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  customers: CustomerCreateNestedManyWithoutOrganizationInput
  description: String
  domain: String!
  email: String!
  linkedinUrl: String!
  logo: OrganizationLogoCreateNestedOneWithoutOrganizationInput
  name: String!
  phone: String
  status: OranizationStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input OrganizationCreateManyInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  id: Int
  linkedinUrl: String!
  name: String!
  phone: String
  status: OranizationStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input OrganizationCreateNestedOneWithoutCustomersInput {
  connect: OrganizationWhereUniqueInput
  connectOrCreate: OrganizationCreateOrConnectWithoutCustomersInput
  create: OrganizationCreateWithoutCustomersInput
}

input OrganizationCreateOrConnectWithoutCustomersInput {
  create: OrganizationCreateWithoutCustomersInput!
  where: OrganizationWhereUniqueInput!
}

input OrganizationCreateWithoutCustomersInput {
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime
  description: String
  domain: String!
  email: String!
  linkedinUrl: String!
  logo: OrganizationLogoCreateNestedOneWithoutOrganizationInput
  name: String!
  phone: String
  status: OranizationStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

type OrganizationGroupBy {
  _avg: OrganizationAvgAggregate
  _count: OrganizationCountAggregate
  _max: OrganizationMaxAggregate
  _min: OrganizationMinAggregate
  _sum: OrganizationSumAggregate
  address: String
  city: String
  company: String!
  country: String
  createdAt: DateTime!
  description: String
  domain: String!
  email: String!
  id: Int!
  linkedinUrl: String!
  name: String!
  phone: String
  status: OranizationStatus!
  taxIdentifier: String
  updatedAt: DateTime!
  website: String
  zipcode: String
}

type OrganizationLogo {
  id: ID!
  organization: Organization!
  organizationId: Int!
  src: String!
  title: String!
}

input OrganizationLogoCreateNestedOneWithoutOrganizationInput {
  connect: OrganizationLogoWhereUniqueInput
  connectOrCreate: OrganizationLogoCreateOrConnectWithoutOrganizationInput
  create: OrganizationLogoCreateWithoutOrganizationInput
}

input OrganizationLogoCreateOrConnectWithoutOrganizationInput {
  create: OrganizationLogoCreateWithoutOrganizationInput!
  where: OrganizationLogoWhereUniqueInput!
}

input OrganizationLogoCreateWithoutOrganizationInput {
  src: String!
  title: String!
}

input OrganizationLogoNullableRelationFilter {
  is: OrganizationLogoWhereInput
  isNot: OrganizationLogoWhereInput
}

input OrganizationLogoOrderByWithRelationInput {
  id: SortOrder
  organization: OrganizationOrderByWithRelationInput
  organizationId: SortOrder
  src: SortOrder
  title: SortOrder
}

input OrganizationLogoUpdateOneWithoutOrganizationNestedInput {
  connect: OrganizationLogoWhereUniqueInput
  connectOrCreate: OrganizationLogoCreateOrConnectWithoutOrganizationInput
  create: OrganizationLogoCreateWithoutOrganizationInput
  delete: OrganizationLogoWhereInput
  disconnect: OrganizationLogoWhereInput
  update: OrganizationLogoUpdateToOneWithWhereWithoutOrganizationInput
  upsert: OrganizationLogoUpsertWithoutOrganizationInput
}

input OrganizationLogoUpdateToOneWithWhereWithoutOrganizationInput {
  data: OrganizationLogoUpdateWithoutOrganizationInput!
  where: OrganizationLogoWhereInput
}

input OrganizationLogoUpdateWithoutOrganizationInput {
  src: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input OrganizationLogoUpsertWithoutOrganizationInput {
  create: OrganizationLogoCreateWithoutOrganizationInput!
  update: OrganizationLogoUpdateWithoutOrganizationInput!
  where: OrganizationLogoWhereInput
}

input OrganizationLogoWhereInput {
  AND: [OrganizationLogoWhereInput!]
  NOT: [OrganizationLogoWhereInput!]
  OR: [OrganizationLogoWhereInput!]
  id: IntFilter
  organization: OrganizationRelationFilter
  organizationId: IntFilter
  src: StringFilter
  title: StringFilter
}

input OrganizationLogoWhereUniqueInput {
  AND: [OrganizationLogoWhereInput!]
  NOT: [OrganizationLogoWhereInput!]
  OR: [OrganizationLogoWhereInput!]
  id: Int
  organization: OrganizationRelationFilter
  organizationId: Int
  src: StringFilter
  title: StringFilter
}

type OrganizationMaxAggregate {
  address: String
  city: String
  company: String
  country: String
  createdAt: DateTime
  description: String
  domain: String
  email: String
  id: Int
  linkedinUrl: String
  name: String
  phone: String
  status: OranizationStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input OrganizationMaxAggregateInput {
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  id: Boolean
  linkedinUrl: Boolean
  name: Boolean
  phone: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input OrganizationMaxOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  id: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  phone: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

type OrganizationMinAggregate {
  address: String
  city: String
  company: String
  country: String
  createdAt: DateTime
  description: String
  domain: String
  email: String
  id: Int
  linkedinUrl: String
  name: String
  phone: String
  status: OranizationStatus
  taxIdentifier: String
  updatedAt: DateTime
  website: String
  zipcode: String
}

input OrganizationMinAggregateInput {
  address: Boolean
  city: Boolean
  company: Boolean
  country: Boolean
  createdAt: Boolean
  description: Boolean
  domain: Boolean
  email: Boolean
  id: Boolean
  linkedinUrl: Boolean
  name: Boolean
  phone: Boolean
  status: Boolean
  taxIdentifier: Boolean
  updatedAt: Boolean
  website: Boolean
  zipcode: Boolean
}

input OrganizationMinOrderByAggregateInput {
  address: SortOrder
  city: SortOrder
  company: SortOrder
  country: SortOrder
  createdAt: SortOrder
  description: SortOrder
  domain: SortOrder
  email: SortOrder
  id: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  phone: SortOrder
  status: SortOrder
  taxIdentifier: SortOrder
  updatedAt: SortOrder
  website: SortOrder
  zipcode: SortOrder
}

input OrganizationOrderByWithAggregationInput {
  _avg: OrganizationAvgOrderByAggregateInput
  _count: OrganizationCountOrderByAggregateInput
  _max: OrganizationMaxOrderByAggregateInput
  _min: OrganizationMinOrderByAggregateInput
  _sum: OrganizationSumOrderByAggregateInput
  address: SortOrderInput
  city: SortOrderInput
  company: SortOrder
  country: SortOrderInput
  createdAt: SortOrder
  description: SortOrderInput
  domain: SortOrder
  email: SortOrder
  id: SortOrder
  linkedinUrl: SortOrder
  name: SortOrder
  phone: SortOrderInput
  status: SortOrder
  taxIdentifier: SortOrderInput
  updatedAt: SortOrder
  website: SortOrderInput
  zipcode: SortOrderInput
}

input OrganizationOrderByWithRelationInput {
  address: SortOrderInput
  city: SortOrderInput
  company: SortOrder
  country: SortOrderInput
  createdAt: SortOrder
  customers: CustomerOrderByRelationAggregateInput
  description: SortOrderInput
  domain: SortOrder
  email: SortOrder
  id: SortOrder
  linkedinUrl: SortOrder
  logo: OrganizationLogoOrderByWithRelationInput
  name: SortOrder
  phone: SortOrderInput
  status: SortOrder
  taxIdentifier: SortOrderInput
  updatedAt: SortOrder
  website: SortOrderInput
  zipcode: SortOrderInput
}

input OrganizationRelationFilter {
  is: OrganizationWhereInput
  isNot: OrganizationWhereInput
}

enum OrganizationScalarFieldEnum {
  address
  city
  company
  country
  createdAt
  description
  domain
  email
  id
  linkedinUrl
  name
  phone
  status
  taxIdentifier
  updatedAt
  website
  zipcode
}

input OrganizationScalarWhereWithAggregatesInput {
  AND: [OrganizationScalarWhereWithAggregatesInput!]
  NOT: [OrganizationScalarWhereWithAggregatesInput!]
  OR: [OrganizationScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  city: StringNullableWithAggregatesFilter
  company: StringWithAggregatesFilter
  country: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  domain: StringWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  linkedinUrl: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  phone: StringNullableWithAggregatesFilter
  status: EnumOranizationStatusWithAggregatesFilter
  taxIdentifier: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  website: StringNullableWithAggregatesFilter
  zipcode: StringNullableWithAggregatesFilter
}

type OrganizationSumAggregate {
  id: Int
}

input OrganizationSumAggregateInput {
  id: Boolean
}

input OrganizationSumOrderByAggregateInput {
  id: SortOrder
}

input OrganizationUpdateInput {
  address: NullableStringFieldUpdateOperationsInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customers: CustomerUpdateManyWithoutOrganizationNestedInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: OrganizationLogoUpdateOneWithoutOrganizationNestedInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  status: EnumOranizationStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input OrganizationUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  status: EnumOranizationStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input OrganizationUpdateOneRequiredWithoutCustomersNestedInput {
  connect: OrganizationWhereUniqueInput
  connectOrCreate: OrganizationCreateOrConnectWithoutCustomersInput
  create: OrganizationCreateWithoutCustomersInput
  update: OrganizationUpdateToOneWithWhereWithoutCustomersInput
  upsert: OrganizationUpsertWithoutCustomersInput
}

input OrganizationUpdateToOneWithWhereWithoutCustomersInput {
  data: OrganizationUpdateWithoutCustomersInput!
  where: OrganizationWhereInput
}

input OrganizationUpdateWithoutCustomersInput {
  address: NullableStringFieldUpdateOperationsInput
  city: NullableStringFieldUpdateOperationsInput
  company: StringFieldUpdateOperationsInput
  country: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  domain: StringFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  linkedinUrl: StringFieldUpdateOperationsInput
  logo: OrganizationLogoUpdateOneWithoutOrganizationNestedInput
  name: StringFieldUpdateOperationsInput
  phone: NullableStringFieldUpdateOperationsInput
  status: EnumOranizationStatusFieldUpdateOperationsInput
  taxIdentifier: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  website: NullableStringFieldUpdateOperationsInput
  zipcode: NullableStringFieldUpdateOperationsInput
}

input OrganizationUpsertWithoutCustomersInput {
  create: OrganizationCreateWithoutCustomersInput!
  update: OrganizationUpdateWithoutCustomersInput!
  where: OrganizationWhereInput
}

input OrganizationWhereInput {
  AND: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  address: StringNullableFilter
  city: StringNullableFilter
  company: StringFilter
  country: StringNullableFilter
  createdAt: DateTimeFilter
  customers: CustomerListRelationFilter
  description: StringNullableFilter
  domain: StringFilter
  email: StringFilter
  id: IntFilter
  linkedinUrl: StringFilter
  logo: OrganizationLogoNullableRelationFilter
  name: StringFilter
  phone: StringNullableFilter
  status: EnumOranizationStatusFilter
  taxIdentifier: StringNullableFilter
  updatedAt: DateTimeFilter
  website: StringNullableFilter
  zipcode: StringNullableFilter
}

input OrganizationWhereUniqueInput {
  AND: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  address: StringNullableFilter
  city: StringNullableFilter
  company: StringFilter
  country: StringNullableFilter
  createdAt: DateTimeFilter
  customers: CustomerListRelationFilter
  description: StringNullableFilter
  domain: StringFilter
  email: String
  id: Int
  linkedinUrl: StringFilter
  logo: OrganizationLogoNullableRelationFilter
  name: StringFilter
  phone: StringNullableFilter
  status: EnumOranizationStatusFilter
  taxIdentifier: StringNullableFilter
  updatedAt: DateTimeFilter
  website: StringNullableFilter
  zipcode: StringNullableFilter
}

type Query {
  aggregateAgentTerritory(
    _avg: AgentTerritoryAvgAggregateInput
    _count: AgentTerritoryCountAggregateInput
    _max: AgentTerritoryMaxAggregateInput
    _min: AgentTerritoryMinAggregateInput
    _sum: AgentTerritorySumAggregateInput
    cursor: AgentTerritoryWhereUniqueInput
    orderBy: [AgentTerritoryOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: AgentTerritoryWhereInput
  ): AggregateAgentTerritory!
  aggregateContact(
    _avg: ContactAvgAggregateInput
    _count: ContactCountAggregateInput
    _max: ContactMaxAggregateInput
    _min: ContactMinAggregateInput
    _sum: ContactSumAggregateInput
    cursor: ContactWhereUniqueInput
    orderBy: [ContactOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ContactWhereInput
  ): AggregateContact!
  aggregateCustomer(
    _avg: CustomerAvgAggregateInput
    _count: CustomerCountAggregateInput
    _max: CustomerMaxAggregateInput
    _min: CustomerMinAggregateInput
    _sum: CustomerSumAggregateInput
    cursor: CustomerWhereUniqueInput
    orderBy: [CustomerOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: CustomerWhereInput
  ): AggregateCustomer!
  aggregateOrganization(
    _avg: OrganizationAvgAggregateInput
    _count: OrganizationCountAggregateInput
    _max: OrganizationMaxAggregateInput
    _min: OrganizationMinAggregateInput
    _sum: OrganizationSumAggregateInput
    cursor: OrganizationWhereUniqueInput
    orderBy: [OrganizationOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: OrganizationWhereInput
  ): AggregateOrganization!
  aggregateServiceTerritory(
    _avg: ServiceTerritoryAvgAggregateInput
    _count: ServiceTerritoryCountAggregateInput
    _max: ServiceTerritoryMaxAggregateInput
    _min: ServiceTerritoryMinAggregateInput
    _sum: ServiceTerritorySumAggregateInput
    cursor: ServiceTerritoryWhereUniqueInput
    orderBy: [ServiceTerritoryOrderByWithRelationInput!]
    skip: Int
    take: Int
    where: ServiceTerritoryWhereInput
  ): AggregateServiceTerritory!
  findFirstAgentTerritory(
    cursor: AgentTerritoryWhereUniqueInput
    distinct: [AgentTerritoryScalarFieldEnum!]
    orderBy: [AgentTerritoryOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: AgentTerritoryWhereInput
  ): AgentTerritory!
  findFirstContact(
    cursor: ContactWhereUniqueInput
    distinct: [ContactScalarFieldEnum!]
    orderBy: [ContactOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: ContactWhereInput
  ): Contact!
  findFirstCustomer(
    cursor: CustomerWhereUniqueInput
    distinct: [CustomerScalarFieldEnum!]
    orderBy: [CustomerOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: CustomerWhereInput
  ): Customer!
  findFirstOrganization(
    cursor: OrganizationWhereUniqueInput
    distinct: [OrganizationScalarFieldEnum!]
    orderBy: [OrganizationOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: OrganizationWhereInput
  ): Organization!
  findFirstServiceTerritory(
    cursor: ServiceTerritoryWhereUniqueInput
    distinct: [ServiceTerritoryScalarFieldEnum!]
    orderBy: [ServiceTerritoryOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: ServiceTerritoryWhereInput
  ): ServiceTerritory!
  findUniqueAgentTerritory(
    relationLoadStrategy: RelationLoadStrategy
    where: AgentTerritoryWhereUniqueInput!
  ): AgentTerritory!
  findUniqueContact(
    include: IncludeContactInput
    relationLoadStrategy: RelationLoadStrategy
    where: ContactWhereUniqueInput!
  ): Contact!
  findUniqueCustomer(
    include: IncludeCustomerInput
    relationLoadStrategy: RelationLoadStrategy
    where: CustomerWhereUniqueInput!
  ): Customer!
  findUniqueOrganization(
    relationLoadStrategy: RelationLoadStrategy
    where: OrganizationWhereUniqueInput!
  ): Organization!
  findUniqueServiceTerritory(
    relationLoadStrategy: RelationLoadStrategy
    where: ServiceTerritoryWhereUniqueInput!
  ): ServiceTerritory!
  groupByAgentTerritory(
    _avg: AgentTerritoryAvgAggregateInput
    _count: AgentTerritoryCountAggregateInput
    _max: AgentTerritoryMaxAggregateInput
    _min: AgentTerritoryMinAggregateInput
    _sum: AgentTerritorySumAggregateInput
    by: [AgentTerritoryScalarFieldEnum!]!
    having: AgentTerritoryScalarWhereWithAggregatesInput
    orderBy: [AgentTerritoryOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: AgentTerritoryWhereInput
  ): [AgentTerritoryGroupBy!]!
  groupByContact(
    _avg: ContactAvgAggregateInput
    _count: ContactCountAggregateInput
    _max: ContactMaxAggregateInput
    _min: ContactMinAggregateInput
    _sum: ContactSumAggregateInput
    by: [ContactScalarFieldEnum!]!
    having: ContactScalarWhereWithAggregatesInput
    orderBy: [ContactOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: ContactWhereInput
  ): [ContactGroupBy!]!
  groupByCustomer(
    _avg: CustomerAvgAggregateInput
    _count: CustomerCountAggregateInput
    _max: CustomerMaxAggregateInput
    _min: CustomerMinAggregateInput
    _sum: CustomerSumAggregateInput
    by: [CustomerScalarFieldEnum!]!
    having: CustomerScalarWhereWithAggregatesInput
    orderBy: [CustomerOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: CustomerWhereInput
  ): [CustomerGroupBy!]!
  groupByOrganization(
    _avg: OrganizationAvgAggregateInput
    _count: OrganizationCountAggregateInput
    _max: OrganizationMaxAggregateInput
    _min: OrganizationMinAggregateInput
    _sum: OrganizationSumAggregateInput
    by: [OrganizationScalarFieldEnum!]!
    having: OrganizationScalarWhereWithAggregatesInput
    orderBy: [OrganizationOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: OrganizationWhereInput
  ): [OrganizationGroupBy!]!
  groupByServiceTerritory(
    _avg: ServiceTerritoryAvgAggregateInput
    _count: ServiceTerritoryCountAggregateInput
    _max: ServiceTerritoryMaxAggregateInput
    _min: ServiceTerritoryMinAggregateInput
    _sum: ServiceTerritorySumAggregateInput
    by: [ServiceTerritoryScalarFieldEnum!]!
    having: ServiceTerritoryScalarWhereWithAggregatesInput
    orderBy: [ServiceTerritoryOrderByWithAggregationInput!]
    skip: Int
    take: Int
    where: ServiceTerritoryWhereInput
  ): [ServiceTerritoryGroupBy!]!
  listAgentTerritorys(
    cursor: AgentTerritoryWhereUniqueInput
    distinct: [AgentTerritoryScalarFieldEnum!]
    orderBy: [AgentTerritoryOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: AgentTerritoryWhereInput
  ): [AgentTerritory!]!
  listContacts(
    cursor: ContactWhereUniqueInput
    distinct: [ContactScalarFieldEnum!]
    include: IncludeContactInput
    orderBy: [ContactOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: ContactWhereInput
  ): [Contact!]!
  listCustomers(
    cursor: CustomerWhereUniqueInput
    distinct: [CustomerScalarFieldEnum!]
    include: IncludeCustomerInput
    orderBy: [CustomerOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: CustomerWhereInput
  ): [Customer!]!
  listOrganizations(
    cursor: OrganizationWhereUniqueInput
    distinct: [OrganizationScalarFieldEnum!]
    orderBy: [OrganizationOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: OrganizationWhereInput
  ): [Organization!]!
  listServiceTerritorys(
    cursor: ServiceTerritoryWhereUniqueInput
    distinct: [ServiceTerritoryScalarFieldEnum!]
    orderBy: [ServiceTerritoryOrderByWithRelationInput!]
    relationLoadStrategy: RelationLoadStrategy
    skip: Int
    take: Int
    where: ServiceTerritoryWhereInput
  ): [ServiceTerritory!]!
}

enum QueryMode {
  default
  insensitive
}

enum RelationLoadStrategy {
  join
  query
}

type SLA {
  createdAt: DateTime!
  id: ID!
  parameter: String!
  service: Service!
  serviceId: Int!
  updatedAt: DateTime!
  value: String!
}

input SLACreateManyServiceInput {
  createdAt: DateTime
  id: Int
  parameter: String!
  updatedAt: DateTime
  value: String!
}

input SLACreateManyServiceInputEnvelope {
  data: [SLACreateManyServiceInput!]!
  skipDuplicates: Boolean
}

input SLACreateNestedManyWithoutServiceInput {
  connect: [SLAWhereUniqueInput!]
  connectOrCreate: [SLACreateOrConnectWithoutServiceInput!]
  create: [SLACreateWithoutServiceInput!]
  createMany: SLACreateManyServiceInputEnvelope
}

input SLACreateOrConnectWithoutServiceInput {
  create: SLACreateWithoutServiceInput!
  where: SLAWhereUniqueInput!
}

input SLACreateWithoutServiceInput {
  createdAt: DateTime
  parameter: String!
  updatedAt: DateTime
  value: String!
}

input SLAListRelationFilter {
  every: SLAWhereInput
  none: SLAWhereInput
  some: SLAWhereInput
}

input SLAScalarWhereInput {
  AND: [SLAScalarWhereInput!]
  NOT: [SLAScalarWhereInput!]
  OR: [SLAScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  parameter: StringFilter
  serviceId: IntFilter
  updatedAt: DateTimeFilter
  value: StringFilter
}

input SLAUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  parameter: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input SLAUpdateManyWithWhereWithoutServiceInput {
  data: SLAUpdateManyMutationInput!
  where: SLAScalarWhereInput!
}

input SLAUpdateManyWithoutServiceNestedInput {
  connect: [SLAWhereUniqueInput!]
  connectOrCreate: [SLACreateOrConnectWithoutServiceInput!]
  create: [SLACreateWithoutServiceInput!]
  createMany: SLACreateManyServiceInputEnvelope
  delete: [SLAWhereUniqueInput!]
  deleteMany: [SLAScalarWhereInput!]
  disconnect: [SLAWhereUniqueInput!]
  set: [SLAWhereUniqueInput!]
  update: [SLAUpdateWithWhereUniqueWithoutServiceInput!]
  updateMany: [SLAUpdateManyWithWhereWithoutServiceInput!]
  upsert: [SLAUpsertWithWhereUniqueWithoutServiceInput!]
}

input SLAUpdateWithWhereUniqueWithoutServiceInput {
  data: SLAUpdateWithoutServiceInput!
  where: SLAWhereUniqueInput!
}

input SLAUpdateWithoutServiceInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  parameter: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input SLAUpsertWithWhereUniqueWithoutServiceInput {
  create: SLACreateWithoutServiceInput!
  update: SLAUpdateWithoutServiceInput!
  where: SLAWhereUniqueInput!
}

input SLAWhereInput {
  AND: [SLAWhereInput!]
  NOT: [SLAWhereInput!]
  OR: [SLAWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  parameter: StringFilter
  service: ServiceRelationFilter
  serviceId: IntFilter
  updatedAt: DateTimeFilter
  value: StringFilter
}

input SLAWhereUniqueInput {
  AND: [SLAWhereInput!]
  NOT: [SLAWhereInput!]
  OR: [SLAWhereInput!]
  createdAt: DateTimeFilter
  id: Int
  parameter: StringFilter
  service: ServiceRelationFilter
  serviceId: IntFilter
  updatedAt: DateTimeFilter
  value: StringFilter
}

type Service {
  _count: ServiceCount!
  createdAt: DateTime!
  customer: Customer!
  customerId: Int!
  description: String!
  id: ID!
  name: String!
  sla: [SLA!]
  updatedAt: DateTime!
}

type ServiceCount {
  sla: Int!
}

input ServiceCreateManyCustomerInput {
  createdAt: DateTime
  description: String!
  id: Int
  name: String!
  updatedAt: DateTime
}

input ServiceCreateManyCustomerInputEnvelope {
  data: [ServiceCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input ServiceCreateNestedManyWithoutCustomerInput {
  connect: [ServiceWhereUniqueInput!]
  connectOrCreate: [ServiceCreateOrConnectWithoutCustomerInput!]
  create: [ServiceCreateWithoutCustomerInput!]
  createMany: ServiceCreateManyCustomerInputEnvelope
}

input ServiceCreateOrConnectWithoutCustomerInput {
  create: ServiceCreateWithoutCustomerInput!
  where: ServiceWhereUniqueInput!
}

input ServiceCreateWithoutCustomerInput {
  createdAt: DateTime
  description: String!
  name: String!
  sla: SLACreateNestedManyWithoutServiceInput
  updatedAt: DateTime
}

input ServiceListRelationFilter {
  every: ServiceWhereInput
  none: ServiceWhereInput
  some: ServiceWhereInput
}

input ServiceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ServiceRelationFilter {
  is: ServiceWhereInput
  isNot: ServiceWhereInput
}

input ServiceScalarWhereInput {
  AND: [ServiceScalarWhereInput!]
  NOT: [ServiceScalarWhereInput!]
  OR: [ServiceScalarWhereInput!]
  createdAt: DateTimeFilter
  customerId: IntFilter
  description: StringFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

type ServiceTerritory {
  _count: ServiceTerritoryCount!
  city: String!
  country: String!
  id: ID!
  isocode: String!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  state: String!
  subTerritories: [SubTerritory!]
}

type ServiceTerritoryAvgAggregate {
  id: Float
  latitude: Float
  longitude: Float
}

input ServiceTerritoryAvgAggregateInput {
  id: Boolean
  latitude: Boolean
  longitude: Boolean
}

input ServiceTerritoryAvgOrderByAggregateInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
}

type ServiceTerritoryCount {
  subTerritories: Int!
}

type ServiceTerritoryCountAggregate {
  _all: Int!
  city: Int!
  country: Int!
  id: Int!
  isocode: Int!
  latitude: Int!
  locality: Int!
  longitude: Int!
  name: Int!
  state: Int!
}

input ServiceTerritoryCountAggregateInput {
  _all: Boolean
  city: Boolean
  country: Boolean
  id: Boolean
  isocode: Boolean
  latitude: Boolean
  locality: Boolean
  longitude: Boolean
  name: Boolean
  state: Boolean
}

input ServiceTerritoryCountOrderByAggregateInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  isocode: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  state: SortOrder
}

input ServiceTerritoryCreateInput {
  city: String!
  country: String!
  isocode: String!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  state: String!
  subTerritories: SubTerritoryCreateNestedManyWithoutParentTerritoryInput
}

input ServiceTerritoryCreateManyInput {
  city: String!
  country: String!
  id: Int
  isocode: String!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  state: String!
}

input ServiceTerritoryCreateNestedOneWithoutSubTerritoriesInput {
  connect: ServiceTerritoryWhereUniqueInput
  connectOrCreate: ServiceTerritoryCreateOrConnectWithoutSubTerritoriesInput
  create: ServiceTerritoryCreateWithoutSubTerritoriesInput
}

input ServiceTerritoryCreateOrConnectWithoutSubTerritoriesInput {
  create: ServiceTerritoryCreateWithoutSubTerritoriesInput!
  where: ServiceTerritoryWhereUniqueInput!
}

input ServiceTerritoryCreateWithoutSubTerritoriesInput {
  city: String!
  country: String!
  isocode: String!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  state: String!
}

type ServiceTerritoryGroupBy {
  _avg: ServiceTerritoryAvgAggregate
  _count: ServiceTerritoryCountAggregate
  _max: ServiceTerritoryMaxAggregate
  _min: ServiceTerritoryMinAggregate
  _sum: ServiceTerritorySumAggregate
  city: String!
  country: String!
  id: Int!
  isocode: String!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  state: String!
}

type ServiceTerritoryMaxAggregate {
  city: String
  country: String
  id: Int
  isocode: String
  latitude: Float
  locality: String
  longitude: Float
  name: String
  state: String
}

input ServiceTerritoryMaxAggregateInput {
  city: Boolean
  country: Boolean
  id: Boolean
  isocode: Boolean
  latitude: Boolean
  locality: Boolean
  longitude: Boolean
  name: Boolean
  state: Boolean
}

input ServiceTerritoryMaxOrderByAggregateInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  isocode: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  state: SortOrder
}

type ServiceTerritoryMinAggregate {
  city: String
  country: String
  id: Int
  isocode: String
  latitude: Float
  locality: String
  longitude: Float
  name: String
  state: String
}

input ServiceTerritoryMinAggregateInput {
  city: Boolean
  country: Boolean
  id: Boolean
  isocode: Boolean
  latitude: Boolean
  locality: Boolean
  longitude: Boolean
  name: Boolean
  state: Boolean
}

input ServiceTerritoryMinOrderByAggregateInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  isocode: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  state: SortOrder
}

input ServiceTerritoryOrderByWithAggregationInput {
  _avg: ServiceTerritoryAvgOrderByAggregateInput
  _count: ServiceTerritoryCountOrderByAggregateInput
  _max: ServiceTerritoryMaxOrderByAggregateInput
  _min: ServiceTerritoryMinOrderByAggregateInput
  _sum: ServiceTerritorySumOrderByAggregateInput
  city: SortOrder
  country: SortOrder
  id: SortOrder
  isocode: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  state: SortOrder
}

input ServiceTerritoryOrderByWithRelationInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  isocode: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  state: SortOrder
  subTerritories: SubTerritoryOrderByRelationAggregateInput
}

input ServiceTerritoryRelationFilter {
  is: ServiceTerritoryWhereInput
  isNot: ServiceTerritoryWhereInput
}

enum ServiceTerritoryScalarFieldEnum {
  city
  country
  id
  isocode
  latitude
  locality
  longitude
  name
  state
}

input ServiceTerritoryScalarWhereWithAggregatesInput {
  AND: [ServiceTerritoryScalarWhereWithAggregatesInput!]
  NOT: [ServiceTerritoryScalarWhereWithAggregatesInput!]
  OR: [ServiceTerritoryScalarWhereWithAggregatesInput!]
  city: StringWithAggregatesFilter
  country: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  isocode: StringWithAggregatesFilter
  latitude: FloatWithAggregatesFilter
  locality: StringWithAggregatesFilter
  longitude: FloatWithAggregatesFilter
  name: StringWithAggregatesFilter
  state: StringWithAggregatesFilter
}

type ServiceTerritorySumAggregate {
  id: Int
  latitude: Float
  longitude: Float
}

input ServiceTerritorySumAggregateInput {
  id: Boolean
  latitude: Boolean
  longitude: Boolean
}

input ServiceTerritorySumOrderByAggregateInput {
  id: SortOrder
  latitude: SortOrder
  longitude: SortOrder
}

input ServiceTerritoryUpdateInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  isocode: StringFieldUpdateOperationsInput
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  subTerritories: SubTerritoryUpdateManyWithoutParentTerritoryNestedInput
}

input ServiceTerritoryUpdateManyMutationInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  isocode: StringFieldUpdateOperationsInput
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
}

input ServiceTerritoryUpdateOneRequiredWithoutSubTerritoriesNestedInput {
  connect: ServiceTerritoryWhereUniqueInput
  connectOrCreate: ServiceTerritoryCreateOrConnectWithoutSubTerritoriesInput
  create: ServiceTerritoryCreateWithoutSubTerritoriesInput
  update: ServiceTerritoryUpdateToOneWithWhereWithoutSubTerritoriesInput
  upsert: ServiceTerritoryUpsertWithoutSubTerritoriesInput
}

input ServiceTerritoryUpdateToOneWithWhereWithoutSubTerritoriesInput {
  data: ServiceTerritoryUpdateWithoutSubTerritoriesInput!
  where: ServiceTerritoryWhereInput
}

input ServiceTerritoryUpdateWithoutSubTerritoriesInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  isocode: StringFieldUpdateOperationsInput
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
}

input ServiceTerritoryUpsertWithoutSubTerritoriesInput {
  create: ServiceTerritoryCreateWithoutSubTerritoriesInput!
  update: ServiceTerritoryUpdateWithoutSubTerritoriesInput!
  where: ServiceTerritoryWhereInput
}

input ServiceTerritoryWhereInput {
  AND: [ServiceTerritoryWhereInput!]
  NOT: [ServiceTerritoryWhereInput!]
  OR: [ServiceTerritoryWhereInput!]
  city: StringFilter
  country: StringFilter
  id: IntFilter
  isocode: StringFilter
  latitude: FloatFilter
  locality: StringFilter
  longitude: FloatFilter
  name: StringFilter
  state: StringFilter
  subTerritories: SubTerritoryListRelationFilter
}

input ServiceTerritoryWhereUniqueInput {
  AND: [ServiceTerritoryWhereInput!]
  NOT: [ServiceTerritoryWhereInput!]
  OR: [ServiceTerritoryWhereInput!]
  city: StringFilter
  country: StringFilter
  id: Int
  isocode: StringFilter
  latitude: FloatFilter
  locality: StringFilter
  longitude: FloatFilter
  name: StringFilter
  state: StringFilter
  subTerritories: SubTerritoryListRelationFilter
}

input ServiceUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpdateManyWithWhereWithoutCustomerInput {
  data: ServiceUpdateManyMutationInput!
  where: ServiceScalarWhereInput!
}

input ServiceUpdateManyWithoutCustomerNestedInput {
  connect: [ServiceWhereUniqueInput!]
  connectOrCreate: [ServiceCreateOrConnectWithoutCustomerInput!]
  create: [ServiceCreateWithoutCustomerInput!]
  createMany: ServiceCreateManyCustomerInputEnvelope
  delete: [ServiceWhereUniqueInput!]
  deleteMany: [ServiceScalarWhereInput!]
  disconnect: [ServiceWhereUniqueInput!]
  set: [ServiceWhereUniqueInput!]
  update: [ServiceUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [ServiceUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [ServiceUpsertWithWhereUniqueWithoutCustomerInput!]
}

input ServiceUpdateWithWhereUniqueWithoutCustomerInput {
  data: ServiceUpdateWithoutCustomerInput!
  where: ServiceWhereUniqueInput!
}

input ServiceUpdateWithoutCustomerInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  sla: SLAUpdateManyWithoutServiceNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ServiceUpsertWithWhereUniqueWithoutCustomerInput {
  create: ServiceCreateWithoutCustomerInput!
  update: ServiceUpdateWithoutCustomerInput!
  where: ServiceWhereUniqueInput!
}

input ServiceWhereInput {
  AND: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  description: StringFilter
  id: IntFilter
  name: StringFilter
  sla: SLAListRelationFilter
  updatedAt: DateTimeFilter
}

input ServiceWhereUniqueInput {
  AND: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: IntFilter
  description: StringFilter
  id: Int
  name: StringFilter
  sla: SLAListRelationFilter
  updatedAt: DateTimeFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type SubTerritory {
  _count: SubTerritoryCount!
  agents: [AgentTerritory!]
  id: ID!
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  parentTerritory: ServiceTerritory!
  parentTerritoryId: Int!
}

type SubTerritoryCount {
  agents: Int!
}

input SubTerritoryCreateManyParentTerritoryInput {
  id: Int
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
}

input SubTerritoryCreateManyParentTerritoryInputEnvelope {
  data: [SubTerritoryCreateManyParentTerritoryInput!]!
  skipDuplicates: Boolean
}

input SubTerritoryCreateNestedManyWithoutParentTerritoryInput {
  connect: [SubTerritoryWhereUniqueInput!]
  connectOrCreate: [SubTerritoryCreateOrConnectWithoutParentTerritoryInput!]
  create: [SubTerritoryCreateWithoutParentTerritoryInput!]
  createMany: SubTerritoryCreateManyParentTerritoryInputEnvelope
}

input SubTerritoryCreateNestedOneWithoutAgentsInput {
  connect: SubTerritoryWhereUniqueInput
  connectOrCreate: SubTerritoryCreateOrConnectWithoutAgentsInput
  create: SubTerritoryCreateWithoutAgentsInput
}

input SubTerritoryCreateOrConnectWithoutAgentsInput {
  create: SubTerritoryCreateWithoutAgentsInput!
  where: SubTerritoryWhereUniqueInput!
}

input SubTerritoryCreateOrConnectWithoutParentTerritoryInput {
  create: SubTerritoryCreateWithoutParentTerritoryInput!
  where: SubTerritoryWhereUniqueInput!
}

input SubTerritoryCreateWithoutAgentsInput {
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
  parentTerritory: ServiceTerritoryCreateNestedOneWithoutSubTerritoriesInput!
}

input SubTerritoryCreateWithoutParentTerritoryInput {
  agents: AgentTerritoryCreateNestedManyWithoutSubTerritoryInput
  latitude: Float!
  locality: String!
  longitude: Float!
  name: String!
}

input SubTerritoryListRelationFilter {
  every: SubTerritoryWhereInput
  none: SubTerritoryWhereInput
  some: SubTerritoryWhereInput
}

input SubTerritoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubTerritoryOrderByWithRelationInput {
  agents: AgentTerritoryOrderByRelationAggregateInput
  id: SortOrder
  latitude: SortOrder
  locality: SortOrder
  longitude: SortOrder
  name: SortOrder
  parentTerritory: ServiceTerritoryOrderByWithRelationInput
  parentTerritoryId: SortOrder
}

input SubTerritoryRelationFilter {
  is: SubTerritoryWhereInput
  isNot: SubTerritoryWhereInput
}

input SubTerritoryScalarWhereInput {
  AND: [SubTerritoryScalarWhereInput!]
  NOT: [SubTerritoryScalarWhereInput!]
  OR: [SubTerritoryScalarWhereInput!]
  id: IntFilter
  latitude: FloatFilter
  locality: StringFilter
  longitude: FloatFilter
  name: StringFilter
  parentTerritoryId: IntFilter
}

input SubTerritoryUpdateManyMutationInput {
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SubTerritoryUpdateManyWithWhereWithoutParentTerritoryInput {
  data: SubTerritoryUpdateManyMutationInput!
  where: SubTerritoryScalarWhereInput!
}

input SubTerritoryUpdateManyWithoutParentTerritoryNestedInput {
  connect: [SubTerritoryWhereUniqueInput!]
  connectOrCreate: [SubTerritoryCreateOrConnectWithoutParentTerritoryInput!]
  create: [SubTerritoryCreateWithoutParentTerritoryInput!]
  createMany: SubTerritoryCreateManyParentTerritoryInputEnvelope
  delete: [SubTerritoryWhereUniqueInput!]
  deleteMany: [SubTerritoryScalarWhereInput!]
  disconnect: [SubTerritoryWhereUniqueInput!]
  set: [SubTerritoryWhereUniqueInput!]
  update: [SubTerritoryUpdateWithWhereUniqueWithoutParentTerritoryInput!]
  updateMany: [SubTerritoryUpdateManyWithWhereWithoutParentTerritoryInput!]
  upsert: [SubTerritoryUpsertWithWhereUniqueWithoutParentTerritoryInput!]
}

input SubTerritoryUpdateOneRequiredWithoutAgentsNestedInput {
  connect: SubTerritoryWhereUniqueInput
  connectOrCreate: SubTerritoryCreateOrConnectWithoutAgentsInput
  create: SubTerritoryCreateWithoutAgentsInput
  update: SubTerritoryUpdateToOneWithWhereWithoutAgentsInput
  upsert: SubTerritoryUpsertWithoutAgentsInput
}

input SubTerritoryUpdateToOneWithWhereWithoutAgentsInput {
  data: SubTerritoryUpdateWithoutAgentsInput!
  where: SubTerritoryWhereInput
}

input SubTerritoryUpdateWithWhereUniqueWithoutParentTerritoryInput {
  data: SubTerritoryUpdateWithoutParentTerritoryInput!
  where: SubTerritoryWhereUniqueInput!
}

input SubTerritoryUpdateWithoutAgentsInput {
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parentTerritory: ServiceTerritoryUpdateOneRequiredWithoutSubTerritoriesNestedInput
}

input SubTerritoryUpdateWithoutParentTerritoryInput {
  agents: AgentTerritoryUpdateManyWithoutSubTerritoryNestedInput
  latitude: FloatFieldUpdateOperationsInput
  locality: StringFieldUpdateOperationsInput
  longitude: FloatFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input SubTerritoryUpsertWithWhereUniqueWithoutParentTerritoryInput {
  create: SubTerritoryCreateWithoutParentTerritoryInput!
  update: SubTerritoryUpdateWithoutParentTerritoryInput!
  where: SubTerritoryWhereUniqueInput!
}

input SubTerritoryUpsertWithoutAgentsInput {
  create: SubTerritoryCreateWithoutAgentsInput!
  update: SubTerritoryUpdateWithoutAgentsInput!
  where: SubTerritoryWhereInput
}

input SubTerritoryWhereInput {
  AND: [SubTerritoryWhereInput!]
  NOT: [SubTerritoryWhereInput!]
  OR: [SubTerritoryWhereInput!]
  agents: AgentTerritoryListRelationFilter
  id: IntFilter
  latitude: FloatFilter
  locality: StringFilter
  longitude: FloatFilter
  name: StringFilter
  parentTerritory: ServiceTerritoryRelationFilter
  parentTerritoryId: IntFilter
}

input SubTerritoryWhereUniqueInput {
  AND: [SubTerritoryWhereInput!]
  NOT: [SubTerritoryWhereInput!]
  OR: [SubTerritoryWhereInput!]
  agents: AgentTerritoryListRelationFilter
  id: Int
  latitude: FloatFilter
  locality: StringFilter
  longitude: FloatFilter
  name: StringFilter
  parentTerritory: ServiceTerritoryRelationFilter
  parentTerritoryId: IntFilter
}

type WorkCalendar {
  agent: Agent!
  agentId: Int!
  available: Boolean!
  createdAt: DateTime!
  day: Int!
  endTime: DateTime!
  id: ID!
  month: Int!
  startTime: DateTime!
  updatedAt: DateTime!
  year: Int!
}

input WorkCalendarCreateManyAgentInput {
  available: Boolean!
  createdAt: DateTime
  day: Int!
  endTime: DateTime!
  id: Int
  month: Int!
  startTime: DateTime!
  updatedAt: DateTime
  year: Int!
}

input WorkCalendarCreateManyAgentInputEnvelope {
  data: [WorkCalendarCreateManyAgentInput!]!
  skipDuplicates: Boolean
}

input WorkCalendarCreateNestedManyWithoutAgentInput {
  connect: [WorkCalendarWhereUniqueInput!]
  connectOrCreate: [WorkCalendarCreateOrConnectWithoutAgentInput!]
  create: [WorkCalendarCreateWithoutAgentInput!]
  createMany: WorkCalendarCreateManyAgentInputEnvelope
}

input WorkCalendarCreateOrConnectWithoutAgentInput {
  create: WorkCalendarCreateWithoutAgentInput!
  where: WorkCalendarWhereUniqueInput!
}

input WorkCalendarCreateWithoutAgentInput {
  available: Boolean!
  createdAt: DateTime
  day: Int!
  endTime: DateTime!
  month: Int!
  startTime: DateTime!
  updatedAt: DateTime
  year: Int!
}

input WorkCalendarListRelationFilter {
  every: WorkCalendarWhereInput
  none: WorkCalendarWhereInput
  some: WorkCalendarWhereInput
}

input WorkCalendarOrderByRelationAggregateInput {
  _count: SortOrder
}

input WorkCalendarScalarWhereInput {
  AND: [WorkCalendarScalarWhereInput!]
  NOT: [WorkCalendarScalarWhereInput!]
  OR: [WorkCalendarScalarWhereInput!]
  agentId: IntFilter
  available: BoolFilter
  createdAt: DateTimeFilter
  day: IntFilter
  endTime: DateTimeFilter
  id: IntFilter
  month: IntFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input WorkCalendarUpdateManyMutationInput {
  available: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  day: IntFieldUpdateOperationsInput
  endTime: DateTimeFieldUpdateOperationsInput
  month: IntFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input WorkCalendarUpdateManyWithWhereWithoutAgentInput {
  data: WorkCalendarUpdateManyMutationInput!
  where: WorkCalendarScalarWhereInput!
}

input WorkCalendarUpdateManyWithoutAgentNestedInput {
  connect: [WorkCalendarWhereUniqueInput!]
  connectOrCreate: [WorkCalendarCreateOrConnectWithoutAgentInput!]
  create: [WorkCalendarCreateWithoutAgentInput!]
  createMany: WorkCalendarCreateManyAgentInputEnvelope
  delete: [WorkCalendarWhereUniqueInput!]
  deleteMany: [WorkCalendarScalarWhereInput!]
  disconnect: [WorkCalendarWhereUniqueInput!]
  set: [WorkCalendarWhereUniqueInput!]
  update: [WorkCalendarUpdateWithWhereUniqueWithoutAgentInput!]
  updateMany: [WorkCalendarUpdateManyWithWhereWithoutAgentInput!]
  upsert: [WorkCalendarUpsertWithWhereUniqueWithoutAgentInput!]
}

input WorkCalendarUpdateWithWhereUniqueWithoutAgentInput {
  data: WorkCalendarUpdateWithoutAgentInput!
  where: WorkCalendarWhereUniqueInput!
}

input WorkCalendarUpdateWithoutAgentInput {
  available: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  day: IntFieldUpdateOperationsInput
  endTime: DateTimeFieldUpdateOperationsInput
  month: IntFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: IntFieldUpdateOperationsInput
}

input WorkCalendarUpsertWithWhereUniqueWithoutAgentInput {
  create: WorkCalendarCreateWithoutAgentInput!
  update: WorkCalendarUpdateWithoutAgentInput!
  where: WorkCalendarWhereUniqueInput!
}

input WorkCalendarWhereInput {
  AND: [WorkCalendarWhereInput!]
  NOT: [WorkCalendarWhereInput!]
  OR: [WorkCalendarWhereInput!]
  agent: AgentRelationFilter
  agentId: IntFilter
  available: BoolFilter
  createdAt: DateTimeFilter
  day: IntFilter
  endTime: DateTimeFilter
  id: IntFilter
  month: IntFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}

input WorkCalendarWhereUniqueInput {
  AND: [WorkCalendarWhereInput!]
  NOT: [WorkCalendarWhereInput!]
  OR: [WorkCalendarWhereInput!]
  agent: AgentRelationFilter
  agentId: IntFilter
  available: BoolFilter
  createdAt: DateTimeFilter
  day: IntFilter
  endTime: DateTimeFilter
  id: Int
  month: IntFilter
  startTime: DateTimeFilter
  updatedAt: DateTimeFilter
  year: IntFilter
}
